```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Metro Transit Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            background: #2a2a2a;
            cursor: crosshair;
        }

        .hud {
            position: absolute;
            z-index: 10;
            pointer-events: none;
        }

        .top-bar {
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: auto;
        }

        .bottom-bar {
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 14px;
        }

        .stat-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat {
            font-weight: bold;
        }

        .resource-panel {
            position: absolute;
            top: 60px;
            right: -300px;
            width: 280px;
            height: calc(100vh - 60px);
            background: rgba(0, 0, 0, 0.9);
            transition: right 0.3s ease;
            padding: 20px;
            pointer-events: auto;
        }

        .resource-panel.open {
            right: 0;
        }

        .resource-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: #4a4a4a;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 14px;
            transition: background 0.2s;
        }

        .resource-button:hover:not(:disabled) {
            background: #5a5a5a;
        }

        .resource-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-over-modal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .modal-content {
            background: #333;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .modal-content p {
            margin: 10px 0;
        }

        .modal-button {
            padding: 10px 20px;
            margin: 10px;
            background: #4a90e2;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }

        .modal-button:hover {
            background: #357abd;
        }

        .pause-modal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .tutorial-modal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .tutorial-content {
            background: #333;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            text-align: center;
        }

        .tutorial-step {
            display: none;
            margin: 20px 0;
        }

        .tutorial-step.active {
            display: block;
        }

        .clickable {
            pointer-events: auto;
            cursor: pointer;
        }

        .notification {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(74, 144, 226, 0.9);
            padding: 15px;
            border-radius: 5px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            pointer-events: none;
        }

        .notification.show {
            transform: translateX(0);
        }

        @media (max-width: 768px) {
            .top-bar {
                padding: 0 10px;
                font-size: 14px;
            }
            
            .stat-group {
                gap: 10px;
            }
            
            .resource-panel {
                width: 100%;
                right: -100%;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD Elements -->
    <div class="hud top-bar">
        <div class="stat-group">
            <span class="stat">Week: <span id="weekDisplay">1</span></span>
            <span class="stat">Month: <span id="monthDisplay">1</span></span>
        </div>
        <div class="stat-group">
            <span class="stat">Delivered: <span id="scoreDisplay">0</span></span>
            <span class="stat clickable" id="tokensDisplay" style="color: #4a90e2;">Tokens: 0</span>
            <button class="modal-button" id="pauseButton">‚è∏</button>
        </div>
    </div>

    <div class="hud bottom-bar">
        <span id="tooltipDisplay">Draw lines between stations to connect them. Trains will carry passengers to matching colored stations.</span>
    </div>

    <!-- Resource Panel -->
    <div class="resource-panel" id="resourcePanel">
        <h3>Spend Resources</h3>
        <button class="resource-button" id="addTrainBtn" data-cost="1">
            üöÇ Add Train (1 Token)
            <br><small>Add a new train to an existing line</small>
        </button>
        <button class="resource-button" id="addCarriageBtn" data-cost="1">
            üöÉ Add Carriage (1 Token)
            <br><small>Increase train capacity by 4</small>
        </button>
        <button class="resource-button" id="addLineBtn" data-cost="1">
            üìè New Line (1 Token)
            <br><small>Unlock ability to draw another line</small>
        </button>
        <button class="resource-button" id="addTunnelBtn" data-cost="1">
            üöá Tunnel (1 Token)
            <br><small>Cross barriers with next line segment</small>
        </button>
        <button class="resource-button" id="closeResourcePanel">Close</button>
    </div>

    <!-- Game Over Modal -->
    <div class="game-over-modal" id="gameOverModal">
        <div class="modal-content">
            <h2>Game Over!</h2>
            <p id="gameOverReason">Station Overloaded</p>
            <p>Time Survived: <span id="finalWeek">0</span> weeks</p>
            <p>Passengers Delivered: <span id="finalScore">0</span></p>
            <p>Average Wait Time: <span id="avgWaitTime">0.0s</span></p>
            <button class="modal-button" id="restartButton">Restart Game</button>
        </div>
    </div>

    <!-- Pause Modal -->
    <div class="pause-modal" id="pauseModal">
        <div class="modal-content">
            <h2>Game Paused</h2>
            <button class="modal-button" id="resumeButton">Resume</button>
            <button class="modal-button" id="restartFromPauseButton">Restart</button>
            <button class="modal-button" id="tutorialButton">Tutorial</button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="tutorial-modal" id="tutorialModal" style="display: none;">
        <div class="tutorial-content">
            <div class="tutorial-step active">
                <h3>Welcome to Mini Metro!</h3>
                <p>Build an efficient transit network by connecting stations with colored lines.</p>
                <button class="modal-button" onclick="nextTutorialStep()">Next</button>
            </div>
            <div class="tutorial-step">
                <h3>Drawing Lines</h3>
                <p>Click and drag from one station to another to create your first line. Trains will automatically run on your lines.</p>
                <button class="modal-button" onclick="nextTutorialStep()">Next</button>
            </div>
            <div class="tutorial-step">
                <h3>Passengers & Colors</h3>
                <p>Colored passengers appear at stations and want to travel to stations of matching color. Keep queues short!</p>
                <button class="modal-button" onclick="nextTutorialStep()">Next</button>
            </div>
            <div class="tutorial-step">
                <h3>Resources & Upgrades</h3>
                <p>Every week you'll receive tokens. Spend them to add trains, carriages, new lines, and tunnels. Click the 'Tokens' counter to spend.</p>
                <button class="modal-button" onclick="nextTutorialStep()">Next</button>
            </div>
            <div class="tutorial-step">
                <h3>Win Condition</h3>
                <p>If any station's queue exceeds 20 passengers, you lose! Build smart and keep traffic flowing.</p>
                <button class="modal-button" onclick="startGame()">Start Playing!</button>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // Game Constants
        const STATION_COLORS = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b'];
        const LINE_COLORS = ['#666', '#777', '#888', '#999', '#aaa', '#bbb'];
        const STATION_RADIUS = 15;
        const TRAIN_SIZE = 8;
        const MAX_QUEUE_LENGTH = 20;
        const REAL_SECONDS_PER_WEEK = 20; // Faster for demo
        const DEFAULT_TRAIN_SPEED = 80;
        const DEFAULT_TRAIN_CAPACITY = 4;

        // Game State
        let gameState = {
            stations: new Map(),
            lines: new Map(),
            trains: new Map(),
            passengers: new Map(),
            nextStationID: 1,
            nextLineID: 1,
            nextTrainID: 1,
            nextPassengerID: 1,
            score: 0,
            totalWaitTime: 0,
            deliveredCount: 0,
            week: 1,
            month: 1,
            isGameOver: false,
            isPaused: false,
            tokens: 1, // Start with 1 token
            maxLines: 2,
            usedLines: 0,
            tunnelsAvailable: 0
        };

        // Timing variables
        let lastTime = 0;
        let stationSpawnTimer = 0;
        let passengerSpawnTimer = 0;
        let weekTimer = 0;
        let stationSpawnInterval = 8;
        let passengerSpawnInterval = 1.2;

        // UI state
        let selectedStation = null;
        let isDragging = false;
        let dragEndX = 0;
        let dragEndY = 0;
        let mouseX = 0;
        let mouseY = 0;
        let showingResourcePanel = false;
        let pendingResourceAction = null; // 'addTrain', 'addCarriage'
        let tutorialStep = 0;

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
        }

        // Classes
        class Station {
            constructor(x, y, color) {
                this.id = gameState.nextStationID++;
                this.x = x;
                this.y = y;
                this.color = color;
                this.queue = [];
                this.isOverloaded = false;
            }

            addPassenger(passenger) {
                this.queue.push(passenger.id);
                if (this.queue.length >= MAX_QUEUE_LENGTH && !gameState.isGameOver) {
                    this.isOverloaded = true;
                    endGame(`Station overloaded! Queue reached ${this.queue.length} passengers.`);
                }
            }

            removePassenger(passengerId) {
                const index = this.queue.indexOf(passengerId);
                if (index > -1) {
                    this.queue.splice(index, 1);
                }
            }

            draw() {
                const pulseTime = performance.now() * 0.005;
                const isWarning = this.queue.length >= 15;
                const radius = STATION_RADIUS + (isWarning ? Math.sin(pulseTime) * 3 : 0);
                
                // Station circle
                ctx.fillStyle = this.color;
                ctx.strokeStyle = isWarning ? '#ff0000' : '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Queue visualization
                if (this.queue.length > 0) {
                    const displayCount = Math.min(4, this.queue.length);
                    for (let i = 0; i < displayCount; i++) {
                        const passenger = gameState.passengers.get(this.queue[i]);
                        if (passenger) {
                            const angle = (i / displayCount) * Math.PI * 2;
                            const qx = this.x + Math.cos(angle) * (radius - 6);
                            const qy = this.y + Math.sin(angle) * (radius - 6);
                            
                            ctx.fillStyle = passenger.targetColor;
                            ctx.beginPath();
                            ctx.arc(qx, qy, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    if (this.queue.length > 4) {
                        ctx.fillStyle = 'white';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`+${this.queue.length - 4}`, this.x, this.y + radius + 15);
                    }
                }
            }
        }

        class Line {
            constructor() {
                this.id = gameState.nextLineID++;
                this.stations = [];
                this.trains = [];
                this.color = LINE_COLORS[gameState.usedLines % LINE_COLORS.length];
                gameState.usedLines++;
                this.colorStationsMap = {};
            }

            addStation(stationId) {
                if (!this.stations.includes(stationId)) {
                    this.stations.push(stationId);
                    this.updateColorMap();
                }
            }

            updateColorMap() {
                this.colorStationsMap = {};
                this.stations.forEach((stationId, index) => {
                    const station = gameState.stations.get(stationId);
                    if (station) {
                        if (!this.colorStationsMap[station.color]) {
                            this.colorStationsMap[station.color] = [];
                        }
                        this.colorStationsMap[station.color].push(index);
                    }
                });
            }

            canReachColor(fromIndex, targetColor, direction) {
                const colorIndices = this.colorStationsMap[targetColor] || [];
                return colorIndices.some(index => {
                    if (direction === 'forward') return index > fromIndex;
                    if (direction === 'backward') return index < fromIndex;
                    return false;
                });
            }

            draw() {
                if (this.stations.length < 2) return;

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                for (let i = 0; i < this.stations.length - 1; i++) {
                    const station1 = gameState.stations.get(this.stations[i]);
                    const station2 = gameState.stations.get(this.stations[i + 1]);
                    if (station1 && station2) {
                        if (i === 0) ctx.moveTo(station1.x, station1.y);
                        ctx.lineTo(station2.x, station2.y);
                    }
                }
                ctx.stroke();
            }
        }

        class Train {
            constructor(lineId) {
                this.id = gameState.nextTrainID++;
                this.lineId = lineId;
                this.currentStationIndex = 0;
                this.direction = 'forward';
                this.speed = DEFAULT_TRAIN_SPEED;
                this.capacity = DEFAULT_TRAIN_CAPACITY;
                this.passengers = [];
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
                
                const line = gameState.lines.get(lineId);
                if (line && line.stations.length > 0) {
                    const firstStation = gameState.stations.get(line.stations[0]);
                    if (firstStation) {
                        this.x = firstStation.x;
                        this.y = firstStation.y;
                        this.updateTarget();
                    }
                }
            }

            updateTarget() {
                const line = gameState.lines.get(this.lineId);
                if (!line || line.stations.length < 2) return;

                let nextIndex = this.direction === 'forward'
                    ? this.currentStationIndex + 1
                    : this.currentStationIndex - 1;

                if (nextIndex >= line.stations.length) {
                    this.direction = 'backward';
                    this.currentStationIndex = line.stations.length - 1;
                    nextIndex = this.currentStationIndex - 1;
                } else if (nextIndex < 0) {
                    this.direction = 'forward';
                    this.currentStationIndex = 0;
                    nextIndex = this.currentStationIndex + 1;
                }

                const targetStation = gameState.stations.get(line.stations[nextIndex]);
                if (targetStation) {
                    this.targetX = targetStation.x;
                    this.targetY = targetStation.y;
                }
            }

            update(deltaTime) {
                if (gameState.isPaused || gameState.isGameOver) return;

                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 2) {
                    this.arriveAtStation();
                } else {
                    const moveDistance = this.speed * deltaTime;
                    this.x += (dx / distance) * moveDistance;
                    this.y += (dy / distance) * moveDistance;
                }
            }

            arriveAtStation() {
                const line = gameState.lines.get(this.lineId);
                if (!line) return;

                let nextIndex = this.direction === 'forward'
                    ? this.currentStationIndex + 1
                    : this.currentStationIndex - 1;

                this.currentStationIndex = nextIndex;
                const currentStation = gameState.stations.get(line.stations[nextIndex]);
                
                if (currentStation) {
                    this.x = currentStation.x;
                    this.y = currentStation.y;
                    
                    // Deboard passengers
                    this.passengers = this.passengers.filter(passengerId => {
                        const passenger = gameState.passengers.get(passengerId);
                        if (passenger && passenger.targetColor === currentStation.color) {
                            gameState.score++;
                            gameState.deliveredCount++;
                            gameState.totalWaitTime += passenger.waitDuration;
                            gameState.passengers.delete(passengerId);
                            updateUI();
                            return false; // Remove from train
                        }
                        return true; // Keep on train
                    });

                    // Board new passengers
                    const availableCapacity = this.capacity - this.passengers.length;
                    let boarded = 0;
                    
                    for (let i = 0; i < currentStation.queue.length && boarded < availableCapacity; i++) {
                        const passengerId = currentStation.queue[i];
                        const passenger = gameState.passengers.get(passengerId);
                        
                        if (passenger && this.canReachColor(passenger.targetColor)) {
                            this.passengers.push(passengerId);
                            currentStation.removePassenger(passengerId);
                            boarded++;
                            i--; // Adjust index since we removed an element
                        }
                    }
                }

                this.updateTarget();
            }

            canReachColor(targetColor) {
                const line = gameState.lines.get(this.lineId);
                if (!line) return false;
                
                return line.canReachColor(this.currentStationIndex, targetColor, this.direction) ||
                       line.canReachColor(this.currentStationIndex, targetColor, 
                           this.direction === 'forward' ? 'backward' : 'forward');
            }

            draw() {
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, TRAIN_SIZE, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Capacity indicator
                ctx.fillStyle = 'black';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.passengers.length}/${this.capacity}`, this.x, this.y - TRAIN_SIZE - 5);
            }
        }

        class Passenger {
            constructor(originStationId, targetColor) {
                this.id = gameState.nextPassengerID++;
                this.originStationId = originStationId;
                this.targetColor = targetColor;
                this.spawnTime = performance.now();
                this.waitDuration = 0;
            }

            update(deltaTime) {
                this.waitDuration += deltaTime;
            }
        }

        // Game Functions
        function initGame() {
            // Reset game state
            gameState = {
                stations: new Map(),
                lines: new Map(),
                trains: new Map(),
                passengers: new Map(),
                nextStationID: 1,
                nextLineID: 1,
                nextTrainID: 1,
                nextPassengerID: 1,
                score: 0,
                totalWaitTime: 0,
                deliveredCount: 0,
                week: 1,
                month: 1,
                isGameOver: false,
                isPaused: true, // start paused until tutorial closes
                tokens: 1,
                maxLines: 2,
                usedLines: 0,
                tunnelsAvailable: 0
            };

            // Reset timers
            stationSpawnTimer = 0;
            passengerSpawnTimer = 0;
            weekTimer = 0;
            stationSpawnInterval = 8;
            passengerSpawnInterval = 1.2;

            // Spawn initial stations
            spawnStation();
            spawnStation();
            setTimeout(spawnStation, 2000);

            updateUI();
        }

        function spawnStation() {
            if (gameState.isGameOver) return;

            let attempts = 0;
            let x, y;
            const minDistance = 80;
            const maxAttempts = 20;
            
            do {
                x = Math.random() * (window.innerWidth - 100) + 50;
                y = Math.random() * (window.innerHeight - 160) + 80;
                attempts++;
            } while (
                attempts < maxAttempts &&
                Array.from(gameState.stations.values()).some(station => {
                    const dx = station.x - x;
                    const dy = station.y - y;
                    return Math.sqrt(dx * dx + dy * dy) < minDistance;
                })
            );

            const color = STATION_COLORS[Math.floor(Math.random() * STATION_COLORS.length)];
            const station = new Station(x, y, color);
            gameState.stations.set(station.id, station);
        }

        function spawnPassenger() {
            if (gameState.isGameOver || gameState.stations.size === 0) return;

            const stations = Array.from(gameState.stations.values());
            const randomStation = stations[Math.floor(Math.random() * stations.length)];
            
            // Get available colors (excluding the station's own color)
            const availableColors = STATION_COLORS.filter(color => color !== randomStation.color);
            if (availableColors.length === 0) return;

            const targetColor = availableColors[Math.floor(Math.random() * availableColors.length)];
            const passenger = new Passenger(randomStation.id, targetColor);
            
            gameState.passengers.set(passenger.id, passenger);
            randomStation.addPassenger(passenger);
        }

        function updateGameLogic(deltaTime) {
            if (gameState.isPaused || gameState.isGameOver) return;

            // Update timers
            stationSpawnTimer += deltaTime;
            passengerSpawnTimer += deltaTime;
            weekTimer += deltaTime;

            // Spawn stations
            if (stationSpawnTimer >= stationSpawnInterval) {
                spawnStation();
                stationSpawnTimer = 0;
            }

            // Spawn passengers
            if (passengerSpawnTimer >= passengerSpawnInterval) {
                spawnPassenger();
                passengerSpawnTimer = 0;
            }

            // Week progression
            if (weekTimer >= REAL_SECONDS_PER_WEEK) {
                gameState.week++;
                if (gameState.week > 4) {
                    gameState.week = 1;
                    gameState.month++;
                    // Increase difficulty
                    stationSpawnInterval = Math.max(3, stationSpawnInterval - 0.5);
                    passengerSpawnInterval = Math.max(0.5, passengerSpawnInterval - 0.1);
                }
                gameState.tokens++;
                showNotification(`Week ${gameState.week}: +1 Token`);
                weekTimer = 0;
                updateUI();
            }

            // Update trains
            gameState.trains.forEach(train => train.update(deltaTime));
            
            // Update passengers
            gameState.passengers.forEach(passenger => passenger.update(deltaTime));
        }

        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background grid (subtle)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < window.innerWidth; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, window.innerHeight);
                ctx.stroke();
            }
            for (let y = 0; y < window.innerHeight; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(window.innerWidth, y);
                ctx.stroke();
            }

            // Draw lines
            gameState.lines.forEach(line => line.draw());

            // Draw drag preview
            if (isDragging && selectedStation) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 4;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(selectedStation.x, selectedStation.y);
                ctx.lineTo(dragEndX, dragEndY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw stations
            gameState.stations.forEach(station => station.draw());

            // Draw trains
            gameState.trains.forEach(train => train.draw());
        }

        function gameLoop(timestamp) {
            const deltaTime = Math.min((timestamp - lastTime) / 1000, 0.05);
            lastTime = timestamp;

            updateGameLogic(deltaTime);
            render();

            requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            document.getElementById('weekDisplay').textContent = gameState.week;
            document.getElementById('monthDisplay').textContent = gameState.month;
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('tokensDisplay').textContent = `Tokens: ${gameState.tokens}`;

            // Update resource buttons
            const hasTokens = gameState.tokens > 0;
            document.getElementById('addTrainBtn').disabled = !hasTokens || gameState.lines.size === 0;
            document.getElementById('addCarriageBtn').disabled = !hasTokens || gameState.trains.size === 0;
            document.getElementById('addLineBtn').disabled = !hasTokens || gameState.usedLines >= 6;
            document.getElementById('addTunnelBtn').disabled = !hasTokens;
        }

        function endGame(reason) {
            gameState.isGameOver = true;
            document.getElementById('gameOverReason').textContent = reason;
            const totalWeeks = (gameState.month - 1) * 4 + gameState.week;
            document.getElementById('finalWeek').textContent = totalWeeks;
            document.getElementById('finalScore').textContent = gameState.score;
            const avgWait = gameState.deliveredCount > 0
                ? (gameState.totalWaitTime / gameState.deliveredCount).toFixed(1)
                : '0.0';
            document.getElementById('avgWaitTime').textContent = `${avgWait}s`;
            document.getElementById('gameOverModal').style.display = 'flex';
        }

        // Resource & UI Handlers
        function toggleResourcePanel() {
            showingResourcePanel = !showingResourcePanel;
            document.getElementById('resourcePanel').classList.toggle('open', showingResourcePanel);
        }

        function closeResourcePanel() {
            showingResourcePanel = false;
            document.getElementById('resourcePanel').classList.remove('open');
            pendingResourceAction = null;
            document.getElementById('tooltipDisplay').textContent =
                'Draw lines between stations to connect them. Trains carry passengers to matching colors.';
        }

        function showNotification(text) {
            const notif = document.getElementById('notification');
            notif.textContent = text;
            notif.classList.add('show');
            setTimeout(() => {
                notif.classList.remove('show');
            }, 2000);
        }

        function handleResourceAction(action) {
            if (gameState.tokens <= 0) return;
            gameState.tokens--;
            updateUI();

            if (action === 'addTrain') {
                pendingResourceAction = 'addTrain';
                document.getElementById('tooltipDisplay').textContent = 'Click a station on a line to add a new train.';
            }
            if (action === 'addCarriage') {
                pendingResourceAction = 'addCarriage';
                document.getElementById('tooltipDisplay').textContent = 'Click a train to add +4 capacity.';
            }
            if (action === 'addLine') {
                gameState.maxLines++;
                showNotification('New line unlocked!');
            }
            if (action === 'addTunnel') {
                gameState.tunnelsAvailable++;
                showNotification('Tunnel token acquired! (No barriers implemented)');
            }

            // Auto-close panel if not pending line or tunnel
            if (action !== 'addTrain' && action !== 'addCarriage') {
                setTimeout(closeResourcePanel, 200);
            }
        }

        function tryPlaceTrainAtStation(stationId) {
            // Find a line containing this station
            for (let [lineId, line] of gameState.lines) {
                if (line.stations.includes(stationId)) {
                    const train = new Train(lineId);
                    gameState.trains.set(train.id, train);
                    line.trains.push(train.id);
                    showNotification('Train added to line.');
                    pendingResourceAction = null;
                    updateUI();
                    closeResourcePanel();
                    return true;
                }
            }
            return false;
        }

        function tryAddCarriageToTrainAt(x, y) {
            for (let [trainId, train] of gameState.trains) {
                const dx = train.x - x;
                const dy = train.y - y;
                if (Math.sqrt(dx * dx + dy * dy) <= TRAIN_SIZE + 2) {
                    train.capacity += 4;
                    showNotification('Train capacity increased by 4.');
                    pendingResourceAction = null;
                    updateUI();
                    closeResourcePanel();
                    return true;
                }
            }
            return false;
        }

        function handleNewConnection(stationA, stationB) {
            if (stationA.id === stationB.id) return;

            // Check if already connected directly in some line
            for (let [lineId, line] of gameState.lines) {
                const idxA = line.stations.indexOf(stationA.id);
                const idxB = line.stations.indexOf(stationB.id);
                if (idxA !== -1 && idxB !== -1 && Math.abs(idxA - idxB) === 1) {
                    return; // Already adjacent in this line
                }
            }

            // Find a line that contains either station
            for (let [lineId, line] of gameState.lines) {
                if (line.stations.includes(stationA.id) || line.stations.includes(stationB.id)) {
                    // Insert the other station next to the existing one
                    if (line.stations.includes(stationA.id) && !line.stations.includes(stationB.id)) {
                        const pos = line.stations.indexOf(stationA.id);
                        line.stations.splice(pos + 1, 0, stationB.id);
                        line.updateColorMap();
                    } else if (line.stations.includes(stationB.id) && !line.stations.includes(stationA.id)) {
                        const pos = line.stations.indexOf(stationB.id);
                        line.stations.splice(pos + 1, 0, stationA.id);
                        line.updateColorMap();
                    }
                    return;
                }
            }

            // Neither station is in an existing line
            if (gameState.usedLines < gameState.maxLines) {
                const newLine = new Line();
                newLine.addStation(stationA.id);
                newLine.addStation(stationB.id);
                gameState.lines.set(newLine.id, newLine);
                // Spawn an initial train on this new line
                const train = new Train(newLine.id);
                gameState.trains.set(train.id, train);
                newLine.trains.push(train.id);
            }
        }

        // Input & Interaction
        canvas.addEventListener('mousedown', (e) => {
            if (gameState.isPaused || gameState.isGameOver) return;

            mouseX = e.clientX;
            mouseY = e.clientY;

            // If pending resource action, handle that first
            if (pendingResourceAction === 'addTrain') {
                // Check if clicked station belongs to a line
                for (let [stationId, station] of gameState.stations) {
                    const dx = station.x - mouseX;
                    const dy = station.y - mouseY;
                    if (Math.sqrt(dx * dx + dy * dy) <= STATION_RADIUS) {
                        if (tryPlaceTrainAtStation(stationId)) return;
                    }
                }
                return;
            }

            if (pendingResourceAction === 'addCarriage') {
                if (tryAddCarriageToTrainAt(mouseX, mouseY)) return;
                return;
            }

            // Normal line drawing: check if clicked on station
            for (let [stationId, station] of gameState.stations) {
                const dx = station.x - mouseX;
                const dy = station.y - mouseY;
                if (Math.sqrt(dx * dx + dy * dy) <= STATION_RADIUS) {
                    selectedStation = station;
                    isDragging = true;
                    dragEndX = mouseX;
                    dragEndY = mouseY;
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            dragEndX = mouseX;
            dragEndY = mouseY;

            // Update tooltip
            if (gameState.isPaused || gameState.isGameOver) return;

            let foundTooltip = false;
            // Check station hover
            for (let [_, station] of gameState.stations) {
                const dx = station.x - mouseX;
                const dy = station.y - mouseY;
                if (Math.sqrt(dx * dx + dy * dy) <= STATION_RADIUS) {
                    const counts = {};
                    station.queue.forEach(pid => {
                        const p = gameState.passengers.get(pid);
                        if (p) {
                            counts[p.targetColor] = (counts[p.targetColor] || 0) + 1;
                        }
                    });
                    const breakdown = Object.entries(counts)
                        .map(([color, num]) => `${num}`)
                        .join(', ');
                    document.getElementById('tooltipDisplay').textContent =
                        `Station ${station.id} ‚Ä¢ Queue: ${station.queue.length} ‚Ä¢ Destinations: ${breakdown}`;
                    foundTooltip = true;
                    break;
                }
            }
            if (!foundTooltip) {
                // Check train hover
                for (let [_, train] of gameState.trains) {
                    const dx = train.x - mouseX;
                    const dy = train.y - mouseY;
                    if (Math.sqrt(dx * dx + dy * dy) <= TRAIN_SIZE) {
                        const line = gameState.lines.get(train.lineId);
                        document.getElementById('tooltipDisplay').textContent =
                            `Train on Line ${line.id} ‚Ä¢ Speed: ${train.speed}px/s ‚Ä¢ ` +
                            `Capacity: ${train.passengers.length}/${train.capacity} ‚Ä¢ ` +
                            `Next Station: ${line.stations[train.currentStationIndex]}`;
                        foundTooltip = true;
                        break;
                    }
                }
            }
            if (!foundTooltip && !pendingResourceAction) {
                document.getElementById('tooltipDisplay').textContent =
                    'Draw lines between stations to connect them. Trains carry passengers to matching colors.';
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState.isPaused || gameState.isGameOver) {
                isDragging = false;
                selectedStation = null;
                return;
            }

            if (!isDragging || !selectedStation) return;

            const endX = e.clientX;
            const endY = e.clientY;
            let targetStation = null;

            for (let [_, station] of gameState.stations) {
                const dx = station.x - endX;
                const dy = station.y - endY;
                if (Math.sqrt(dx * dx + dy * dy) <= STATION_RADIUS) {
                    targetStation = station;
                    break;
                }
            }

            if (targetStation) {
                handleNewConnection(selectedStation, targetStation);
            }

            isDragging = false;
            selectedStation = null;
        });

        // Resource panel & buttons
        document.getElementById('tokensDisplay').addEventListener('click', () => {
            toggleResourcePanel();
        });
        document.getElementById('closeResourcePanel').addEventListener('click', closeResourcePanel);

        document.getElementById('addTrainBtn').addEventListener('click', () => {
            handleResourceAction('addTrain');
        });
        document.getElementById('addCarriageBtn').addEventListener('click', () => {
            handleResourceAction('addCarriage');
        });
        document.getElementById('addLineBtn').addEventListener('click', () => {
            handleResourceAction('addLine');
        });
        document.getElementById('addTunnelBtn').addEventListener('click', () => {
            handleResourceAction('addTunnel');
        });

        // Pause & tutorial buttons
        document.getElementById('pauseButton').addEventListener('click', () => {
            gameState.isPaused = true;
            document.getElementById('pauseModal').style.display = 'flex';
        });
        document.getElementById('resumeButton').addEventListener('click', () => {
            gameState.isPaused = false;
            document.getElementById('pauseModal').style.display = 'none';
        });
        document.getElementById('restartFromPauseButton').addEventListener('click', () => {
            document.getElementById('pauseModal').style.display = 'none';
            document.getElementById('gameOverModal').style.display = 'none';
            initGame();
        });
        document.getElementById('tutorialButton').addEventListener('click', () => {
            document.getElementById('tutorialModal').style.display = 'flex';
        });

        // Restart game
        document.getElementById('restartButton').addEventListener('click', () => {
            document.getElementById('gameOverModal').style.display = 'none';
            initGame();
        });

        // Tutorial flow
        function nextTutorialStep() {
            const steps = document.querySelectorAll('.tutorial-step');
            steps[tutorialStep].classList.remove('active');
            tutorialStep++;
            if (tutorialStep < steps.length) {
                steps[tutorialStep].classList.add('active');
            }
        }
        function startGame() {
            document.getElementById('tutorialModal').style.display = 'none';
            gameState.isPaused = false;
        }

        // Setup
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            initGame();
            document.getElementById('tutorialModal').style.display = 'flex';
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
```
