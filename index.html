```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Scale Clone with Dragged Shapes</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #0c0c0c, #1a1a2e);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      font-family: 'Arial', sans-serif;
    }
    #palette {
      margin: 10px;
      display: flex;
      gap: 10px;
    }
    .shape-button {
      width: 60px;
      height: 60px;
      background: #222;
      border: 2px solid #444;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .shape-button.selected {
      border-color: #0ff;
      box-shadow: 0 0 10px rgba(0,255,255,0.5);
    }
    .shape-button canvas {
      pointer-events: none;
    }
    #gameCanvas {
      background: #000;
      border: 3px solid #333;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      touch-action: none;
    }
    .overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      border: 2px solid #0ff;
      display: none;
      z-index: 10;
    }
    .overlay h2 {
      margin: 0 0 15px 0;
      color: #ff6b6b;
    }
    .overlay.level-complete h2 {
      color: #51cf66;
    }
    button {
      background: linear-gradient(45deg, #667eea, #764ba2);
      border: none;
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px;
      transition: all 0.3s ease;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }
  </style>
</head>
<body>
  <div id="palette">
    <div id="rectShapeBtn" class="shape-button" title="Straight Rectangle">
      <canvas id="rectPreview" width="60" height="60"></canvas>
    </div>
    <div id="lShapeBtn" class="shape-button" title="L-Shape">
      <canvas id="lPreview" width="60" height="60"></canvas>
    </div>
  </div>

  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <div id="gameOver" class="overlay">
    <h2>Game Over!</h2>
    <p>Final Level: <span id="finalLevel"></span></p>
    <button onclick="restartGame()">Restart Game</button>
  </div>
  <div id="levelComplete" class="overlay level-complete">
    <h2>Level Complete!</h2>
    <p>Preparing next level...</p>
  </div>

  <script>
    // -------------------------------------------------------------------
    // ClipperLib: Minimalistic polygon-clipping stub (difference only)
    // -------------------------------------------------------------------
    const ClipperLib = {
      PolyType: { ptSubject: 0, ptClip: 1 },
      ClipType: { ctDifference: 3 },
      PolyFillType: { pftNonZero: 1 },
      Clipper: function() {
        this.subjPaths = [];
        this.clipPaths = [];
        this.AddPaths = function(paths, polyType, closed) {
          if (polyType === ClipperLib.PolyType.ptSubject) {
            this.subjPaths = paths;
          } else {
            this.clipPaths = paths;
          }
        };
        this.Execute = function(clipType, solution) {
          if (clipType === ClipperLib.ClipType.ctDifference) {
            const result = this.performDifference(this.subjPaths[0], this.clipPaths[0]);
            solution.length = 0;
            if (result.length > 0) {
              for (let poly of result) solution.push(poly);
            }
          }
          return true;
        };
        this.getEdges = function(poly) {
          const edges = [];
          for (let i = 0; i < poly.length; i++) {
            edges.push({ a: poly[i], b: poly[(i + 1) % poly.length] });
          }
          return edges;
        };
        this.lineIntersection = function(p1, p2, p3, p4) {
          const denom = (p1.X - p2.X)*(p3.Y - p4.Y) - (p1.Y - p2.Y)*(p3.X - p4.X);
          if (Math.abs(denom) < 1e-10) return null;
          const t = ((p1.X - p3.X)*(p3.Y - p4.Y) - (p1.Y - p3.Y)*(p3.X - p4.X)) / denom;
          const u = -((p1.X - p2.X)*(p1.Y - p3.Y) - (p1.Y - p2.Y)*(p1.X - p3.X)) / denom;
          if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
            return { X: Math.round(p1.X + t*(p2.X - p1.X)), Y: Math.round(p1.Y + t*(p2.Y - p1.Y)) };
          }
          return null;
        };
        this.findIntersections = function(poly, rect) {
          const inters = [];
          const rectEdges = this.getEdges(rect);
          for (let i = 0; i < poly.length; i++) {
            const edge1 = { a: poly[i], b: poly[(i + 1) % poly.length] };
            for (let edge2 of rectEdges) {
              const ip = this.lineIntersection(edge1.a, edge1.b, edge2.a, edge2.b);
              if (ip) inters.push(ip);
            }
          }
          return inters;
        };
        this.pointToLineDistance = function(pt, ls, le) {
          const A = le.Y - ls.Y, B = ls.X - le.X, C = le.X*ls.Y - ls.X*le.Y;
          return A*pt.X + B*pt.Y + C;
        };
        this.splitPolygonByLine = function(poly, cutRect) {
          const lineA = cutRect[0], lineC = cutRect[2];
          const side1 = [], side2 = [];
          for (let v of poly) {
            const d = this.pointToLineDistance({ X: Math.round(v.x*1000), Y: Math.round(v.y*1000) }, lineA, lineC);
            if (d > 0) side1.push(v);
            else side2.push(v);
          }
          const result = [];
          if (side1.length >= 3) result.push(side1);
          if (side2.length >= 3) result.push(side2);
          return result.length ? result : [poly];
        };
        this.performDifference = function(subject, clip) {
          const subjPts = subject.map(p => ({ x: p.X/1000, y: p.Y/1000 }));
          const clipPts = clip.map(p => ({ x: p.X/1000, y: p.Y/1000 }));
          const intersections = this.findIntersections(subject, clip);
          if (intersections.length === 0) return [subjPts];
          return this.splitPolygonByLine(subjPts, clip);
        };
      },
      Paths: function() { return []; }
    };

    // -------------------------------------------------------------------
    // Global Game Variables & State
    // -------------------------------------------------------------------
    let canvas, ctx;
    let lastTimestamp = 0;
    let gameState = 'playing'; // 'playing', 'gameOver', 'levelComplete', 'scaling'

    const GAME = {
      width: 800,
      height: 600,
      playfield: null,
      balls: [],
      activeShape: null,      // { vertices: [...], offsetX, offsetY }
      mousePos: { x: 0, y: 0 },
      level: 0,
      lives: 3,
      targetPercent: 70,
      remainingArea: 1.0,
      initialArea: 0,
      animationData: null
    };

    // Base shape definitions (centered at (0,0))
    const SHAPES = {
      rect: {
        vertices: [
          { x: -75, y: -10 },
          { x:  75, y: -10 },
          { x:  75, y:  10 },
          { x: -75, y:  10 }
        ]
      },
      L: {
        vertices: [
          { x: -30, y: -30 },
          { x:  10, y: -30 },
          { x:  10, y:  10 },
          { x:  30, y:  10 },
          { x:  30, y:  30 },
          { x: -30, y:  30 }
        ]
      }
    };

    // -------------------------------------------------------------------
    // Utility & Geometry Functions
    // -------------------------------------------------------------------
    function toClipper(polygons) {
      return polygons.map(poly =>
        poly.map(pt => ({ X: Math.round(pt.x * 1000), Y: Math.round(pt.y * 1000) }))
      );
    }

    function fromClipper(clipperPolygons) {
      return clipperPolygons.map(poly =>
        poly.map(pt => ({ x: pt.X / 1000, y: pt.Y / 1000 }))
      );
    }

    function polygonArea(poly) {
      let area = 0;
      for (let i = 0; i < poly.length; i++) {
        const a = poly[i], b = poly[(i + 1) % poly.length];
        area += a.x * b.y - b.x * a.y;
      }
      return Math.abs(area) / 2;
    }

    function keepLargest(polygons) {
      let maxArea = -Infinity, idx = 0;
      for (let i = 0; i < polygons.length; i++) {
        const a = polygonArea(polygons[i]);
        if (a > maxArea) { maxArea = a; idx = i; }
      }
      return polygons[idx];
    }

    function orient(a, b, c) {
      return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);
    }

    function segmentsIntersect(p1, p2, p3, p4) {
      const o1 = orient(p1, p2, p3);
      const o2 = orient(p1, p2, p4);
      const o3 = orient(p3, p4, p1);
      const o4 = orient(p3, p4, p2);
      if ((o1 > 0 && o2 < 0 || o1 < 0 && o2 > 0) &&
          (o3 > 0 && o4 < 0 || o3 < 0 && o4 > 0)) {
        return true;
      }
      return false;
    }

    function pointInPolygon(pt, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
          (pt.x < ((xj - xi) * (pt.y - yi)) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function circleSegmentCollision(ball, edge) {
      const { a, b } = edge;
      const vx = b.x - a.x, vy = b.y - a.y;
      const wx = ball.x - a.x, wy = ball.y - a.y;
      const dot = wx*vx + wy*vy, len = vx*vx + vy*vy;
      const proj = Math.max(0, Math.min(1, dot / len));
      const closestX = a.x + proj*vx, closestY = a.y + proj*vy;
      const dx = ball.x - closestX, dy = ball.y - closestY;
      return (dx*dx + dy*dy) <= ball.radius * ball.radius;
    }

    function reflectBall(ball, edge) {
      const { a, b } = edge;
      const ex = b.x - a.x, ey = b.y - a.y;
      const len = Math.hypot(ex, ey);
      if (len === 0) return;
      const ux = ex / len, uy = ey / len;
      const nx = -uy, ny = ux;
      const dot = ball.vx * nx + ball.vy * ny;
      ball.vx = ball.vx - 2 * dot * nx;
      ball.vy = ball.vy - 2 * dot * ny;
      // Nudge out
      ball.x += nx * 2;
      ball.y += ny * 2;
    }

    function getEdges(polygon) {
      const edges = [];
      for (let i = 0; i < polygon.length; i++) {
        edges.push({ a: polygon[i], b: polygon[(i + 1) % polygon.length] });
      }
      return edges;
    }

    function cutWithPolygon(playfield, shapePoly) {
      const subj = toClipper([playfield]);
      const clip = toClipper([shapePoly]);
      const cpr = new ClipperLib.Clipper();
      cpr.AddPaths(subj, ClipperLib.PolyType.ptSubject, true);
      cpr.AddPaths(clip, ClipperLib.PolyType.ptClip, true);
      const solution = new ClipperLib.Paths();
      cpr.Execute(ClipperLib.ClipType.ctDifference, solution);
      if (!solution.length) return [];
      return fromClipper(solution);
    }

    // -------------------------------------------------------------------
    // Core Game Logic: Setup, Update, Rendering, Input, Level Progression
    // -------------------------------------------------------------------
    function generateRandomPolygon() {
      const cx = GAME.width / 2, cy = GAME.height / 2;
      const maxR = Math.min(GAME.width, GAME.height) / 2 - 60;
      const verts = 6 + Math.min(GAME.level, 4); // 6 to 10 vertices
      const angles = [];
      for (let i = 0; i < verts; i++) {
        const base = (Math.PI * 2 / verts) * i;
        const jitter = (Math.random() - 0.5) * (Math.PI / verts) * 0.5;
        angles.push(base + jitter);
      }
      angles.sort((a, b) => a - b);
      const poly = [];
      for (let ang of angles) {
        const rf = 0.7 + 0.3 * Math.random();
        const r = maxR * rf;
        poly.push({ x: cx + Math.cos(ang)*r, y: cy + Math.sin(ang)*r });
      }
      return poly;
    }

    function setupLevel(idx) {
      GAME.level = idx;
      GAME.playfield = generateRandomPolygon();
      GAME.initialArea = polygonArea(GAME.playfield);
      GAME.remainingArea = 1.0;
      GAME.targetPercent = Math.min(90, 70 + idx*2);
      GAME.balls = [];
      const count = Math.min(5, 1 + Math.floor(idx/2));
      for (let i = 0; i < count; i++) {
        const radius = 8 + Math.random()*4;
        const margin = 80;
        const x = margin + Math.random()*(GAME.width - 2*margin);
        const y = margin + Math.random()*(GAME.height - 2*margin);
        const speed = 80 + idx*15 + Math.random()*40;
        const ang = Math.random()*Math.PI*2;
        GAME.balls.push({
          x, y,
          vx: Math.cos(ang)*speed,
          vy: Math.sin(ang)*speed,
          radius,
          color: `hsl(${Math.random()*360},70%,60%)`
        });
      }
    }

    function updateBalls(delta) {
      for (let ball of GAME.balls) {
        ball.x += ball.vx * delta;
        ball.y += ball.vy * delta;
        const edges = getEdges(GAME.playfield);
        for (let edge of edges) {
          if (circleSegmentCollision(ball, edge)) {
            reflectBall(ball, edge);
            break;
          }
        }
      }
    }

    function attemptShapeCut() {
      if (!GAME.activeShape) return;
      // Build translated polygon
      const shapeBase = GAME.activeShape.vertices;
      const px = GAME.mousePos.x, py = GAME.mousePos.y;
      const translated = shapeBase.map(v => ({ x: px + v.x, y: py + v.y }));
      const result = cutWithPolygon(GAME.playfield, translated);
      if (result.length === 0) return;
      GAME.playfield = keepLargest(result);
      const newArea = polygonArea(GAME.playfield);
      GAME.remainingArea = newArea / GAME.initialArea;
      const cutPct = (1 - GAME.remainingArea)*100;
      if (cutPct >= GAME.targetPercent) {
        onLevelComplete();
      }
      GAME.activeShape = null;
      clearShapeSelection();
    }

    function onLevelComplete() {
      gameState = 'scaling';
      document.getElementById('levelComplete').style.display = 'block';
      const pf = GAME.playfield;
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (let p of pf) {
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
      }
      const boxW = maxX - minX, boxH = maxY - minY;
      const scaleX = (GAME.width - 100)/boxW;
      const scaleY = (GAME.height - 100)/boxH;
      const finalScale = Math.min(scaleX, scaleY);
      const cx = (minX + maxX)/2, cy = (minY + maxY)/2;
      const tx = GAME.width/2 - cx*finalScale;
      const ty = GAME.height/2 - cy*finalScale;
      GAME.animationData = {
        startTime: null,
        duration: 1.0,
        startScale: 1,
        finalScale,
        startTx: 0,
        startTy: 0,
        tx,
        ty
      };
      setTimeout(() => {
        document.getElementById('levelComplete').style.display = 'none';
        setupLevel(GAME.level + 1);
        gameState = 'playing';
        GAME.animationData = null;
      }, 2000);
    }

    function loseLife() {
      GAME.lives--;
      if (GAME.lives <= 0) {
        gameState = 'gameOver';
        document.getElementById('finalLevel').textContent = GAME.level + 1;
        document.getElementById('gameOver').style.display = 'block';
      }
    }

    function restartGame() {
      GAME.lives = 3;
      gameState = 'playing';
      document.getElementById('gameOver').style.display = 'none';
      setupLevel(0);
    }

    // -------------------------------------------------------------------
    // Rendering
    // -------------------------------------------------------------------
    function render() {
      ctx.clearRect(0, 0, GAME.width, GAME.height);

      // Starfield background
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      for (let i = 0; i < 50; i++) {
        const x = (Date.now()*0.01 + i*127) % GAME.width;
        const y = (Date.now()*0.007 + i*433) % GAME.height;
        ctx.fillRect(x, y, 1, 1);
      }

      if (gameState === 'scaling' && GAME.animationData) {
        renderScalingAnimation();
        return;
      }

      // Draw playfield polygon
      ctx.fillStyle = 'rgba(0,50,100,0.3)';
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      const pf = GAME.playfield;
      ctx.moveTo(pf[0].x, pf[0].y);
      for (let i = 1; i < pf.length; i++) {
        ctx.lineTo(pf[i].x, pf[i].y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Draw balls with glow
      for (let ball of GAME.balls) {
        ctx.save();
        ctx.shadowColor = ball.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }

      // Draw preview of active shape
      if (GAME.activeShape) {
        const base = GAME.activeShape.vertices;
        const px = GAME.mousePos.x, py = GAME.mousePos.y;
        const verts = base.map(v => ({ x: px + v.x, y: py + v.y }));
        ctx.fillStyle = 'rgba(255,0,0,0.3)';
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(verts[0].x, verts[0].y);
        for (let i = 1; i < verts.length; i++) {
          ctx.lineTo(verts[i].x, verts[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      drawUI();
    }

    function renderScalingAnimation() {
      const anim = GAME.animationData;
      const now = performance.now();
      if (!anim.startTime) anim.startTime = now;
      const t = (now - anim.startTime) / 1000;
      const frac = Math.min(1, t / anim.duration);
      const eased = 1 - Math.pow(1 - frac, 3);

      const curScale = anim.startScale + (anim.finalScale - anim.startScale) * eased;
      const curTx = anim.startTx + (anim.tx - anim.startTx) * eased;
      const curTy = anim.startTy + (anim.ty - anim.startTy) * eased;

      ctx.save();
      ctx.setTransform(curScale, 0, 0, curScale, curTx, curTy);

      // Playfield scaled
      ctx.fillStyle = `rgba(0,255,255,${0.2 + 0.3*frac})`;
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 3 / curScale;
      ctx.beginPath();
      const pf = GAME.playfield;
      ctx.moveTo(pf[0].x, pf[0].y);
      for (let i = 1; i < pf.length; i++) {
        ctx.lineTo(pf[i].x, pf[i].y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Balls scaled
      for (let ball of GAME.balls) {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2 / curScale;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawUI() {
      ctx.font = 'bold 20px Arial';
      ctx.fillStyle = '#00ffff';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;

      // Lives
      const livesText = `Lives: ${GAME.lives}`;
      ctx.strokeText(livesText, 20, 35);
      ctx.fillText(livesText, 20, 35);

      // Level
      const levelText = `Level: ${GAME.level + 1}`;
      ctx.strokeText(levelText, 20, 65);
      ctx.fillText(levelText, 20, 65);

      // Percentage
      const pct = Math.round((1 - GAME.remainingArea) * 100);
      const pctText = `${pct}% / ${GAME.targetPercent}%`;
      const pctWidth = ctx.measureText(pctText).width;
      ctx.strokeText(pctText, GAME.width - pctWidth - 20, 35);
      ctx.fillText(pctText, GAME.width - pctWidth - 20, 35);

      // Progress bar
      const barW = 200, barH = 20;
      const barX = GAME.width - barW - 20, barY = 45;
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 2;
      ctx.strokeRect(barX, barY, barW, barH);
      const progW = (pct / GAME.targetPercent) * barW;
      const grad = ctx.createLinearGradient(barX, barY, barX + barW, barY);
      grad.addColorStop(0, '#ff6b6b');
      grad.addColorStop(0.5, '#feca57');
      grad.addColorStop(1, '#48dbfb');
      ctx.fillStyle = grad;
      ctx.fillRect(barX, barY, Math.min(progW, barW), barH);
    }

    // -------------------------------------------------------------------
    // Main Loop
    // -------------------------------------------------------------------
    function update(delta) {
      if (gameState !== 'playing') return;
      updateBalls(delta);
      // No ball-slice collision: shape placement is instantaneous
    }

    function loop(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const delta = (timestamp - lastTimestamp) / 1000;
      lastTimestamp = timestamp;
      update(delta);
      render();
      requestAnimationFrame(loop);
    }

    // -------------------------------------------------------------------
    // Input Handling & Shape Palette
    // -------------------------------------------------------------------
    function getCanvasCoords(evt) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      let clientX, clientY;
      if (evt.touches && evt.touches.length) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
      }
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    function onCanvasMove(evt) {
      const pos = getCanvasCoords(evt);
      GAME.mousePos = pos;
    }

    function onCanvasClick(evt) {
      if (gameState !== 'playing') return;
      if (GAME.activeShape) {
        attemptShapeCut();
      }
    }

    function clearShapeSelection() {
      GAME.activeShape = null;
      document.getElementById('rectShapeBtn').classList.remove('selected');
      document.getElementById('lShapeBtn').classList.remove('selected');
    }

    document.getElementById('rectShapeBtn').addEventListener('click', () => {
      clearShapeSelection();
      GAME.activeShape = { vertices: SHAPES.rect.vertices };
      document.getElementById('rectShapeBtn').classList.add('selected');
    });
    document.getElementById('lShapeBtn').addEventListener('click', () => {
      clearShapeSelection();
      GAME.activeShape = { vertices: SHAPES.L.vertices };
      document.getElementById('lShapeBtn').classList.add('selected');
    });

    // -------------------------------------------------------------------
    // Draw palette previews
    // -------------------------------------------------------------------
    function drawPalette() {
      const rectCv = document.getElementById('rectPreview').getContext('2d');
      rectCv.clearRect(0, 0, 60, 60);
      rectCv.fillStyle = '#ff0000';
      rectCv.strokeStyle = '#fff';
      rectCv.lineWidth = 2;
      rectCv.translate(30, 30);
      rectCv.beginPath();
      const r = SHAPES.rect.vertices;
      rectCv.moveTo(r[0].x * 0.3, r[0].y * 0.3);
      for (let i = 1; i < r.length; i++) {
        rectCv.lineTo(r[i].x * 0.3, r[i].y * 0.3);
      }
      rectCv.closePath();
      rectCv.fill();
      rectCv.stroke();
      rectCv.resetTransform();

      const lCv = document.getElementById('lPreview').getContext('2d');
      lCv.clearRect(0, 0, 60, 60);
      lCv.fillStyle = '#ff0000';
      lCv.strokeStyle = '#fff';
      lCv.lineWidth = 2;
      lCv.translate(30, 30);
      const l = SHAPES.L.vertices;
      lCv.beginPath();
      lCv.moveTo(l[0].x * 0.3, l[0].y * 0.3);
      for (let i = 1; i < l.length; i++) {
        lCv.lineTo(l[i].x * 0.3, l[i].y * 0.3);
      }
      lCv.closePath();
      lCv.fill();
      lCv.stroke();
      lCv.resetTransform();
    }

    // -------------------------------------------------------------------
    // Initialization
    // -------------------------------------------------------------------
    function init() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');

      canvas.width = GAME.width;
      canvas.height = GAME.height;

      // Responsive sizing
      function resizeCanvas() {
        const ar = GAME.width / GAME.height;
        const wr = window.innerWidth / window.innerHeight;
        if (wr > ar) {
          canvas.style.height = '80vh';
          canvas.style.width = (80 * ar) + 'vh';
        } else {
          canvas.style.width = '80vw';
          canvas.style.height = (80 / ar) + 'vw';
        }
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      setupLevel(0);
      drawPalette();

      canvas.addEventListener('mousemove', onCanvasMove);
      canvas.addEventListener('click', onCanvasClick);

      requestAnimationFrame(loop);
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
```
