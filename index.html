<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mini Motorways ‚Äì Traffic Network Builder</title>
  <style>
    /* --------------------
       BASE STYLES
       -------------------- */
    :root {
      --bg-dark: #121212;
      --bg-panel: #1e1e1e;
      --fg-light: #e0e0e0;
      --fg-muted: #888;
      --accent: #56c0e8;
      --warning: #e04e4e;
      --grid-line: rgba(255,255,255,0.05);
      --road-standard: #444;
      --road-dual: #555;
      --road-bridge: #666;
      --road-express: #ffd700;
      --house-size: 18px;
      --dest-size: 20px;
      font-size: 14px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--bg-dark);
      color: var(--fg-light);
      overflow: hidden;
      user-select: none;
    }

    button {
      background: none;
      border: none;
      color: inherit;
      font: inherit;
      cursor: pointer;
    }

    h2, h3 {
      font-weight: 400;
    }

    /* --------------------
       CANVAS
       -------------------- */
    #gameCanvas {
      display: block;
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      background: var(--bg-dark);
    }

    /* --------------------
       HUD ‚Äì Top & Bottom Bars
       -------------------- */
    .hud {
      position: fixed;
      z-index: 100;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      pointer-events: none;
    }

    .top-bar {
      top: 0;
      height: 56px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--grid-line);
      pointer-events: auto;
    }

    .bottom-bar {
      bottom: 0;
      height: 40px;
      background: var(--bg-panel);
      border-top: 1px solid var(--grid-line);
      pointer-events: auto;
      font-size: 13px;
      color: var(--fg-muted);
      padding-left: 16px;
    }

    .stat-item {
      margin-right: 24px;
      display: flex;
      align-items: center;
      font-weight: 300;
      color: var(--fg-light);
    }

    .stat-item span {
      margin-left: 4px;
      color: var(--accent);
      font-weight: 500;
    }

    .top-controls {
      display: flex;
      align-items: center;
    }

    .top-controls button {
      margin-left: 12px;
      background: var(--accent);
      color: var(--bg-dark);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s;
    }

    .top-controls button:hover {
      background: #45abce;
    }

    /* --------------------
       RESOURCE PANEL (SLIDE-OUT)
       -------------------- */
    .resource-panel {
      position: fixed;
      top: 56px;
      right: -280px;
      width: 280px;
      height: calc(100vh - 56px);
      background: var(--bg-panel);
      border-left: 1px solid var(--grid-line);
      padding: 16px;
      overflow-y: auto;
      transition: right 0.25s ease;
      pointer-events: auto;
    }

    .resource-panel.open {
      right: 0;
    }

    .resource-panel h3 {
      font-size: 16px;
      margin-bottom: 12px;
      color: var(--fg-light);
      font-weight: 400;
    }

    .resource-button {
      width: 100%;
      background: transparent;
      border: 1px solid var(--grid-line);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 12px;
      text-align: left;
      color: var(--fg-light);
      transition: background 0.2s, border-color 0.2s;
      font-size: 14px;
      line-height: 1.3;
    }

    .resource-button:hover:not(:disabled) {
      background: rgba(255,255,255,0.05);
      border-color: var(--accent);
    }

    .resource-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* --------------------
       MODALS (PAUSE, GUIDE, GAME OVER)
       -------------------- */
    .modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(18,18,18,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      pointer-events: auto;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: var(--bg-panel);
      border: 1px solid var(--grid-line);
      border-radius: 8px;
      padding: 24px;
      max-width: 440px;
      width: 90%;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }

    .modal-content h2 {
      margin-bottom: 16px;
      font-size: 20px;
      font-weight: 400;
      color: var(--fg-light);
    }

    .modal-content p {
      font-size: 14px;
      margin-bottom: 12px;
      color: var(--fg-light);
      line-height: 1.4;
    }

    .modal-content ul {
      text-align: left;
      margin: 8px 0 16px 0;
      padding-left: 20px;
      color: var(--fg-light);
      font-size: 14px;
      line-height: 1.4;
    }

    .modal-content ul li {
      margin-bottom: 6px;
    }

    .modal-content button {
      background: var(--accent);
      color: var(--bg-dark);
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
      margin-top: 12px;
    }

    .modal-content button:hover {
      background: #45abce;
    }

    .button-danger {
      background: var(--warning);
    }

    .button-danger:hover {
      background: #c13f3f;
    }

    /* --------------------
       NOTIFICATION TOAST
       -------------------- */
    .notification {
      position: fixed;
      top: 72px;
      right: 16px;
      background: var(--accent);
      color: var(--bg-dark);
      padding: 10px 16px;
      border-radius: 4px;
      opacity: 0;
      transform: translateX(100%);
      transition: transform 0.3s ease, opacity 0.3s;
      font-size: 13px;
      z-index: 150;
    }

    .notification.show {
      opacity: 1;
      transform: translateX(0);
    }
  </style>
</head>
<body>
  <!-- CANVAS -->
  <canvas id="gameCanvas"></canvas>

  <!-- TOP BAR -->
  <div class="hud top-bar">
    <div style="display: flex; align-items: center;">
      <div class="stat-item">Week: <span id="weekDisplay">1</span></div>
      <div class="stat-item">Month: <span id="monthDisplay">1</span></div>
    </div>
    <div class="top-controls">
      <div class="stat-item">Delivered: <span id="scoreDisplay">0</span></div>
      <div class="stat-item">Tokens: <span id="tokensDisplay">2</span></div>
      <button onclick="toggleResourcePanel()">üîß Build</button>
      <button onclick="togglePause()">‚è∏ Pause</button>
      <button title="Guide" onclick="toggleGuide()">‚ùî</button>
    </div>
  </div>

  <!-- BOTTOM BAR -->
  <div class="hud bottom-bar">
    <span id="tooltipText">Click a node and drag to build roads. Keep traffic flowing to avoid gridlock.</span>
  </div>

  <!-- RESOURCE PANEL -->
  <div class="hud resource-panel" id="resourcePanel">
    <h3>Construction</h3>
    <button class="resource-button" id="roadBtn" onclick="selectResource('road')">
      <strong>Road (1 Token)</strong><br>
      Place a standard road segment
    </button>
    <button class="resource-button" id="dualBtn" onclick="selectResource('dual')">
      <strong>Dual Lane (1 Token)</strong><br>
      Upgrade an existing road to dual lane
    </button>
    <button class="resource-button" id="roundaboutBtn" onclick="selectResource('roundabout')">
      <strong>Roundabout (2 Tokens)</strong><br>
      Convert a 4-way intersection to a roundabout
    </button>
    <button class="resource-button" id="bridgeBtn" onclick="selectResource('bridge')">
      <strong>Bridge (2 Tokens)</strong><br>
      Build over water or obstacle
    </button>
    <button class="resource-button" id="expresswayBtn" onclick="selectResource('expressway')">
      <strong>Expressway (3 Tokens)</strong><br>
      High-speed straight road
    </button>
  </div>

  <!-- GUIDE MODAL -->
  <div class="modal" id="guideModal">
    <div class="modal-content">
      <h2>How to Play</h2>
      <ul>
        <li>üè† Houses spawn cars of a matching color; connect them to same-color destinations (circles).</li>
        <li>üõ£Ô∏è Click a node (house/destination/intersection), drag to another node, and release to build a road.</li>
        <li>üöó Cars automatically follow the shortest path to a matching destination.</li>
        <li>‚ö†Ô∏è If any house accumulates 12+ queued cars, it overloads and the game ends.</li>
        <li>üîß Every week (20s), you gain 1 token. Spend tokens to build roads or upgrades:</li>
        <ul>
          <li>‚Ä¢ Road (1 Token): Standard single-lane segment.</li>
          <li>‚Ä¢ Dual Lane (1 Token): Upgrade a road‚Äôs capacity √ó2.</li>
          <li>‚Ä¢ Roundabout (2 Tokens): Smooth a 4-way intersection.</li>
          <li>‚Ä¢ Bridge (2 Tokens): Cross rivers/mountains.</li>
          <li>‚Ä¢ Expressway (3 Tokens): Straight, high-speed road.</li>
        </ul>
        <li>üí° Upgrade intersections or build bridges/tunnels to prevent congestion.</li>
        <li>üö¶ Plan ahead‚Äîtraffic jams spread quickly on a small network.</li>
      </ul>
      <button onclick="toggleGuide()">Got It</button>
    </div>
  </div>

  <!-- PAUSE MODAL -->
  <div class="modal" id="pauseModal">
    <div class="modal-content">
      <h2>Game Paused</h2>
      <p>Take a moment to plan your network.</p>
      <button onclick="togglePause()">Resume</button>
      <button class="button-danger" onclick="restartGame()">Restart</button>
      <button onclick="toggleGuide()">Guide</button>
    </div>
  </div>

  <!-- GAME OVER MODAL -->
  <div class="modal" id="gameOverModal">
    <div class="modal-content">
      <h2>Game Over!</h2>
      <p id="gameOverReason">A house became overloaded with traffic.</p>
      <div style="margin: 16px 0; font-size: 14px;">
        <p>Weeks Survived: <strong id="finalWeeks">0</strong></p>
        <p>Cars Delivered: <strong id="finalScore">0</strong></p>
        <p>Average Commute: <strong id="avgCommute">0</strong>s</p>
      </div>
      <button onclick="restartGame()">Play Again</button>
    </div>
  </div>

  <!-- NOTIFICATION TOAST -->
  <div class="notification" id="notification"></div>

  <script>
    // ------------------------------
    //   GAME STATE & CONFIGURATION
    // ------------------------------
    const GameState = {
      stations: new Map(),
      destinations: new Map(),
      roadSegments: new Map(),
      intersections: new Map(),
      cars: new Map(),

      nextStationID: 1,
      nextDestinationID: 1,
      nextSegmentID: 1,
      nextIntersectionID: 1,
      nextCarID: 1,

      score: 0,
      totalWaitTime: 0,
      deliveredCount: 0,

      week: 1,
      month: 1,
      isGameOver: false,
      isPaused: false,

      tokens: 2,
      selectedResource: null,
      selectedNode: null,
      previewLine: null,
      mousePos: { x: 0, y: 0 }
    };

    const COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
    const REAL_SECONDS_PER_WEEK = 20;
    const PASSENGER_SPAWN_INTERVAL = 1.5;
    const STATION_SPAWN_INTERVAL = 15;
    const DESTINATION_SPAWN_INTERVAL = 30;

    // ------------------------------
    //      CANVAS & RENDER LOOP
    // ------------------------------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let lastTime = 0;
    let weekTimer = 0;
    let stationSpawnTimer = 0;
    let destinationSpawnTimer = 0;
    let passengerSpawnTimer = 0;

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resizeCanvas);

    // ------------------------------
    //       GAME OBJECT CLASSES
    // ------------------------------
    class Station {
      constructor(x, y, color) {
        this.id = GameState.nextStationID++;
        this.x = x; this.y = y;
        this.color = color;
        this.queue = []; // array of car IDs waiting to depart
        this.spawnInterval = PASSENGER_SPAWN_INTERVAL;
        this.spawnTimer = 0;
      }

      spawnCar() {
        const choices = Array.from(GameState.destinations.values())
          .filter(dest => dest.color === this.color);
        if (!choices.length) return;

        const dest = choices[Math.floor(Math.random() * choices.length)];
        const path = computeShortestPath(this.id, dest.id);
        if (!path || path.length < 2) return;

        const car = new Car(this.id, dest.id, path);
        GameState.cars.set(car.id, car);
        this.queue.push(car.id);

        if (this.queue.length > 12) {
          endGame(`House overloaded with ${this.queue.length} queued cars!`);
        }
      }

      removeCarFromQueue(carId) {
        const idx = this.queue.indexOf(carId);
        if (idx > -1) this.queue.splice(idx, 1);
      }

      draw(ctx) {
        // House as a small square
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - 9, this.y - 9, 18, 18);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(this.x - 9, this.y - 9, 18, 18);

        // Draw queue count
        if (this.queue.length > 0) {
          ctx.fillStyle = this.queue.length > 8 ? 'var(--warning)' : '#fff';
          ctx.font = '12px Helvetica Neue';
          ctx.textAlign = 'center';
          ctx.fillText(this.queue.length.toString(), this.x, this.y - 14);
        }
      }
    }

    class Destination {
      constructor(x, y, color) {
        this.id = GameState.nextDestinationID++;
        this.x = x; this.y = y;
        this.color = color;
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 11, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
    }

    class RoadSegment {
      constructor(startNodeID, endNodeID, type = 'standard') {
        this.id = GameState.nextSegmentID++;
        this.start = startNodeID;
        this.end = endNodeID;
        this.type = type;

        this.width = type === 'dual' ? 8 : type === 'expressway' ? 10 : 4;
        this.speedLimit = type === 'expressway' ? 160 : 80;
        this.capacity = type === 'dual' ? 2 : 1;
        this.carsOnSegment = [];
      }

      draw(ctx) {
        const a = getNodeByID(this.start);
        const b = getNodeByID(this.end);
        if (!a || !b) return;

        let color = 'var(--road-standard)';
        if (this.type === 'dual') color = 'var(--road-dual)';
        else if (this.type === 'bridge') color = 'var(--road-bridge)';
        else if (this.type === 'expressway') color = 'var(--road-express)';

        ctx.strokeStyle = color;
        ctx.lineWidth = this.width;
        if (this.type === 'bridge') ctx.setLineDash([6,6]);
        else ctx.setLineDash([]);

        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // If congested, draw a semi-transparent red overlay
        if (this.carsOnSegment.length >= this.capacity) {
          ctx.strokeStyle = 'var(--warning)';
          ctx.lineWidth = this.width + 4;
          ctx.globalAlpha = 0.4;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }
    }

    class Intersection {
      constructor(x, y, type = '4way') {
        this.id = GameState.nextIntersectionID++;
        this.x = x; this.y = y;
        this.type = type; // '4way' or 'roundabout'
        this.queue = [];
      }

      draw(ctx) {
        if (this.type === 'roundabout') {
          ctx.strokeStyle = 'var(--road-dual)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
          ctx.stroke();
        }

        if (this.queue.length > 0) {
          ctx.fillStyle = 'var(--warning)';
          ctx.font = '11px Helvetica Neue';
          ctx.textAlign = 'center';
          ctx.fillText(this.queue.length.toString(), this.x, this.y - 16);
        }
      }
    }

    class Car {
      constructor(originStationID, targetDestID, path) {
        this.id = GameState.nextCarID++;
        this.color = GameState.stations.get(originStationID).color;
        this.origin = originStationID;
        this.destination = targetDestID;
        this.path = path.slice(); // array of node IDs
        this.currentEdgeIndex = 0;
        this.progress = 0;
        this.speed = 0;
        this.state = 'WAITING';
        this.spawnTime = performance.now();
        this.waitDuration = 0;
      }

      update(deltaTime) {
        if (this.state === 'WAITING') {
          if (this.currentEdgeIndex >= this.path.length - 1) {
            this.deliverCar();
            return;
          }
          const curr = this.path[this.currentEdgeIndex];
          const nxt = this.path[this.currentEdgeIndex + 1];
          const seg = findSegmentBetween(curr, nxt);
          if (seg && seg.carsOnSegment.length < seg.capacity) {
            const st = GameState.stations.get(this.origin);
            if (st) st.removeCarFromQueue(this.id);
            this.state = 'MOVING';
            this.speed = seg.speedLimit;
            seg.carsOnSegment.push(this.id);
            this.progress = 0;
          } else {
            this.waitDuration += deltaTime;
          }
        }
        else if (this.state === 'MOVING') {
          const curr = this.path[this.currentEdgeIndex];
          const nxt = this.path[this.currentEdgeIndex + 1];
          const seg = findSegmentBetween(curr, nxt);
          if (!seg) {
            GameState.cars.delete(this.id);
            return;
          }
          const a = getNodeByID(curr);
          const b = getNodeByID(nxt);
          const dx = b.x - a.x, dy = b.y - a.y;
          const length = Math.hypot(dx, dy);
          const travelTime = length / seg.speedLimit;
          this.progress += deltaTime / travelTime;

          if (this.progress >= 1) {
            const idx = seg.carsOnSegment.indexOf(this.id);
            if (idx > -1) seg.carsOnSegment.splice(idx, 1);
            this.currentEdgeIndex++;
            if (this.currentEdgeIndex >= this.path.length - 1) {
              this.deliverCar();
            } else {
              const nextNext = this.path[this.currentEdgeIndex + 1];
              const nextSeg = findSegmentBetween(this.path[this.currentEdgeIndex], nextNext);
              if (nextSeg && nextSeg.carsOnSegment.length < nextSeg.capacity) {
                this.state = 'MOVING';
                this.speed = nextSeg.speedLimit;
                nextSeg.carsOnSegment.push(this.id);
                this.progress = 0;
              } else {
                this.state = 'QUEUED';
                this.progress = 0;
              }
            }
          }
        }
        else if (this.state === 'QUEUED') {
          const curr = this.path[this.currentEdgeIndex];
          const nxt = this.path[this.currentEdgeIndex + 1];
          const nextSeg = findSegmentBetween(curr, nxt);
          if (nextSeg && nextSeg.carsOnSegment.length < nextSeg.capacity) {
            this.state = 'MOVING';
            this.speed = nextSeg.speedLimit;
            nextSeg.carsOnSegment.push(this.id);
            this.progress = 0;
          } else {
            this.waitDuration += deltaTime;
          }
        }
      }

      deliverCar() {
        GameState.score++;
        GameState.deliveredCount++;
        GameState.totalWaitTime += (performance.now() - this.spawnTime) / 1000;
        GameState.cars.delete(this.id);
        updateUI();
      }

      draw(ctx) {
        let x, y;
        if (this.state === 'WAITING') {
          const st = GameState.stations.get(this.origin);
          if (st) {
            const qp = st.queue.indexOf(this.id);
            x = st.x + ((qp % 3) - 1) * 6;
            y = st.y + Math.floor(qp / 3) * 6 + 16;
          }
        } else {
          const curr = this.path[this.currentEdgeIndex];
          const nxt = this.path[this.currentEdgeIndex + 1];
          const a = getNodeByID(curr);
          const b = getNodeByID(nxt);
          if (a && b) {
            const dx = b.x - a.x, dy = b.y - a.y;
            x = a.x + dx * Math.min(this.progress, 1);
            y = a.y + dy * Math.min(this.progress, 1);
          }
        }
        if (x !== undefined && y !== undefined) {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // ------------------------------
    //    UTILITY / PATHFINDING
    // ------------------------------
    function getNodeByID(id) {
      return GameState.stations.get(id)
        || GameState.destinations.get(id)
        || GameState.intersections.get(id);
    }

    function findSegmentBetween(aID, bID) {
      for (const seg of GameState.roadSegments.values()) {
        if ((seg.start === aID && seg.end === bID)
         || (seg.start === bID && seg.end === aID)) {
          return seg;
        }
      }
      return null;
    }

    function computeShortestPath(startID, destID) {
      // Simple BFS (all edges equal weight)
      const queue = [[startID]];
      const visited = new Set([startID]);
      while (queue.length) {
        const path = queue.shift();
        const current = path[path.length - 1];
        if (current === destID) return path;
        for (const seg of GameState.roadSegments.values()) {
          let neighbor = null;
          if (seg.start === current) neighbor = seg.end;
          else if (seg.end === current) neighbor = seg.start;
          if (neighbor != null && !visited.has(neighbor)) {
            visited.add(neighbor);
            queue.push([...path, neighbor]);
          }
        }
      }
      return null;
    }

    function distance(x1, y1, x2, y2) {
      return Math.hypot(x2 - x1, y2 - y1);
    }

    function getRandomColor() {
      return COLORS[Math.floor(Math.random() * COLORS.length)];
    }

    function findValidPosition(minDist = 80) {
      const attempts = 50;
      for (let i = 0; i < attempts; i++) {
        const x = Math.random() * (canvas.width - 100) + 50;
        const y = Math.random() * (canvas.height - 200) + 100;
        let ok = true;
        for (const st of GameState.stations.values()) {
          if (distance(x, y, st.x, st.y) < minDist) { ok = false; break; }
        }
        if (!ok) continue;
        for (const dest of GameState.destinations.values()) {
          if (distance(x, y, dest.x, dest.y) < minDist) { ok = false; break; }
        }
        if (ok) return { x, y };
      }
      return { x: canvas.width / 2, y: canvas.height / 2 };
    }

    // ------------------------------
    //    SPAWN & GAME LOGIC
    // ------------------------------
    function spawnStation() {
      const pos = findValidPosition();
      const color = getRandomColor();
      const station = new Station(pos.x, pos.y, color);
      GameState.stations.set(station.id, station);
      updateTooltip(`New ${color} house appeared`);
    }

    function spawnDestination() {
      const pos = findValidPosition();
      const color = getRandomColor();
      const dest = new Destination(pos.x, pos.y, color);
      GameState.destinations.set(dest.id, dest);
      updateTooltip(`New ${color} destination opened`);
    }

    function spawnAllHouseCars() {
      for (const station of GameState.stations.values()) {
        station.spawnTimer += PASSENGER_SPAWN_INTERVAL;
        if (station.spawnTimer >= station.spawnInterval) {
          station.spawnCar();
          station.spawnTimer = 0;
        }
      }
    }

    function updateGameLogic(deltaTime) {
      if (GameState.isPaused || GameState.isGameOver) return;

      stationSpawnTimer += deltaTime;
      destinationSpawnTimer += deltaTime;
      passengerSpawnTimer += deltaTime;
      weekTimer += deltaTime;

      if (stationSpawnTimer >= STATION_SPAWN_INTERVAL) {
        spawnStation();
        stationSpawnTimer = 0;
      }
      if (destinationSpawnTimer >= DESTINATION_SPAWN_INTERVAL) {
        spawnDestination();
        destinationSpawnTimer = 0;
      }
      if (passengerSpawnTimer >= PASSENGER_SPAWN_INTERVAL) {
        spawnAllHouseCars();
        passengerSpawnTimer = 0;
      }
      if (weekTimer >= REAL_SECONDS_PER_WEEK) {
        GameState.week++;
        if (GameState.week > 4) {
          GameState.week = 1;
          GameState.month++;
        }
        GameState.tokens++;
        showNotification(`Week ${GameState.week}: +1 Token`);
        weekTimer = 0;
        updateUI();
      }

      for (const car of GameState.cars.values()) {
        car.update(deltaTime);
      }
    }

    function render() {
      // Clear
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Grid
      ctx.strokeStyle = 'var(--grid-line)';
      ctx.lineWidth = 1;
      const gs = 50;
      for (let x = 0; x < canvas.width; x += gs) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += gs) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw roads
      for (const seg of GameState.roadSegments.values()) {
        seg.draw(ctx);
      }

      // Preview line
      if (GameState.previewLine) {
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 4;
        ctx.setLineDash([5,5]);
        ctx.beginPath();
        ctx.moveTo(GameState.previewLine.startX, GameState.previewLine.startY);
        ctx.lineTo(GameState.previewLine.endX, GameState.previewLine.endY);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Intersections
      for (const inter of GameState.intersections.values()) {
        inter.draw(ctx);
      }

      // Nodes
      for (const st of GameState.stations.values()) st.draw(ctx);
      for (const dest of GameState.destinations.values()) dest.draw(ctx);

      // Cars
      for (const car of GameState.cars.values()) car.draw(ctx);
    }

    function gameLoop(ts) {
      const dt = Math.min((ts - lastTime) / 1000, 0.05);
      lastTime = ts;
      updateGameLogic(dt);
      render();
      requestAnimationFrame(gameLoop);
    }

    // ------------------------------
    //    UI CONTROL FUNCTIONS
    // ------------------------------
    function updateUI() {
      document.getElementById('weekDisplay').textContent = GameState.week;
      document.getElementById('monthDisplay').textContent = GameState.month;
      document.getElementById('scoreDisplay').textContent = GameState.score;
      document.getElementById('tokensDisplay').textContent = GameState.tokens;

      const hasTokens = GameState.tokens > 0;
      document.getElementById('roadBtn').disabled = !hasTokens;
      document.getElementById('dualBtn').disabled = !hasTokens || GameState.roadSegments.size === 0;
      document.getElementById('roundaboutBtn').disabled = !hasTokens || GameState.intersections.size === 0;
      document.getElementById('bridgeBtn').disabled = !hasTokens;
      document.getElementById('expresswayBtn').disabled = !hasTokens;
    }

    function toggleResourcePanel() {
      const panel = document.getElementById('resourcePanel');
      panel.classList.toggle('open');
    }

    function selectResource(type) {
      GameState.selectedResource = type;
      updateTooltip(`Selected: ${type}. Click a node to start.`);
    }

    function togglePause() {
      GameState.isPaused = !GameState.isPaused;
      document.getElementById('pauseModal').classList.toggle('show', GameState.isPaused);
      if (!GameState.isPaused) updateTooltip('Back to building!');
    }

    function restartGame() {
      document.getElementById('pauseModal').classList.remove('show');
      document.getElementById('gameOverModal').classList.remove('show');
      initGame();
    }

    function toggleGuide() {
      const gm = document.getElementById('guideModal');
      gm.classList.toggle('show');
      GameState.isPaused = gm.classList.contains('show');
      updateTooltip(gm.classList.contains('show') ? '' : 'Back to building!');
    }

    function updateTooltip(txt) {
      document.getElementById('tooltipText').textContent = txt;
    }

    function showNotification(txt) {
      const notif = document.getElementById('notification');
      notif.textContent = txt;
      notif.classList.add('show');
      setTimeout(() => notif.classList.remove('show'), 2000);
    }

    function endGame(reason) {
      GameState.isGameOver = true;
      document.getElementById('gameOverReason').textContent = reason;
      const weeks = (GameState.month - 1) * 4 + GameState.week;
      document.getElementById('finalWeeks').textContent = weeks;
      document.getElementById('finalScore').textContent = GameState.score;
      const avg = GameState.deliveredCount
        ? (GameState.totalWaitTime / GameState.deliveredCount).toFixed(1)
        : '0.0';
      document.getElementById('avgCommute').textContent = avg;
      document.getElementById('gameOverModal').classList.add('show');
    }

    // ------------------------------
    //    MOUSE & BUILDING LOGIC
    // ------------------------------
    canvas.addEventListener('mousedown', (e) => {
      if (GameState.isPaused || GameState.isGameOver) return;

      GameState.mousePos.x = e.clientX;
      GameState.mousePos.y = e.clientY;
      const r = GameState.selectedResource;

      // If building roads, pick a node under cursor
      if (r === 'road' || r === 'bridge' || r === 'expressway') {
        for (const node of [
          ...GameState.stations.values(),
          ...GameState.destinations.values(),
          ...GameState.intersections.values()
        ]) {
          if (distance(e.clientX, e.clientY, node.x, node.y) <= 20) {
            GameState.selectedNode = node;
            GameState.previewLine = {
              startX: node.x,
              startY: node.y,
              endX: e.clientX,
              endY: e.clientY
            };
            return;
          }
        }
      }
      // If upgrading roads
      else if (r === 'dual') {
        for (const seg of GameState.roadSegments.values()) {
          const a = getNodeByID(seg.start), b = getNodeByID(seg.end);
          const proj = projectOnSegment(a.x, a.y, b.x, b.y, e.clientX, e.clientY);
          if (distance(e.clientX, e.clientY, proj.x, proj.y) <= 6) {
            if (GameState.tokens >= 1 && seg.type === 'standard') {
              seg.type = 'dual';
              seg.width = 8;
              seg.speedLimit += 10;
              seg.capacity = 2;
              GameState.tokens--;
              updateUI();
              showNotification('Road upgraded to dual lane');
            }
            return;
          }
        }
      }
      // If upgrading intersections
      else if (r === 'roundabout') {
        for (const inter of GameState.intersections.values()) {
          if (distance(e.clientX, e.clientY, inter.x, inter.y) <= 15
              && GameState.tokens >= 2 && inter.type === '4way') {
            inter.type = 'roundabout';
            GameState.tokens -= 2;
            updateUI();
            showNotification('Intersection upgraded to roundabout');
            return;
          }
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      GameState.mousePos.x = e.clientX;
      GameState.mousePos.y = e.clientY;
      if (GameState.previewLine) {
        GameState.previewLine.endX = e.clientX;
        GameState.previewLine.endY = e.clientY;
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (GameState.isPaused || GameState.isGameOver) {
        GameState.previewLine = null;
        GameState.selectedNode = null;
        return;
      }
      const { x, y } = GameState.mousePos;
      const r = GameState.selectedResource;

      if (GameState.previewLine && GameState.selectedNode) {
        let target = null;
        for (const node of [
          ...GameState.stations.values(),
          ...GameState.destinations.values(),
          ...GameState.intersections.values()
        ]) {
          if (node !== GameState.selectedNode
              && distance(x, y, node.x, node.y) <= 20) {
            target = node;
            break;
          }
        }
        if (target && GameState.tokens > 0) {
          let type = 'standard';
          if (r === 'bridge') type = 'bridge';
          else if (r === 'expressway') {
            const dx = Math.abs(target.x - GameState.selectedNode.x);
            const dy = Math.abs(target.y - GameState.selectedNode.y);
            if (dx < dy * 0.1) type = 'expressway';
            else if (dy < dx * 0.1) type = 'expressway';
            else {
              updateTooltip('Expressway must be straight horizontal or vertical.');
              GameState.previewLine = null;
              GameState.selectedNode = null;
              return;
            }
          }
          if (!findSegmentBetween(GameState.selectedNode.id, target.id)) {
            const seg = new RoadSegment(GameState.selectedNode.id, target.id, type);
            GameState.roadSegments.set(seg.id, seg);
            // If node now has 3+ connections ‚Üí create intersection
            [GameState.selectedNode, target].forEach(node => {
              let cnt = 0;
              for (const s of GameState.roadSegments.values()) {
                if (s.start === node.id || s.end === node.id) cnt++;
              }
              if (cnt >= 3 && !GameState.intersections.has(node.id)) {
                const inter = new Intersection(node.x, node.y, '4way');
                GameState.intersections.set(inter.id, inter);
              }
            });
            GameState.tokens--;
            updateUI();
            showNotification('Road built');
          }
        }
      }

      GameState.previewLine = null;
      GameState.selectedNode = null;
    });

    function projectOnSegment(x1,y1,x2,y2,px,py) {
      const dx = x2 - x1, dy = y2 - y1;
      const len2 = dx*dx + dy*dy;
      if (len2 === 0) return { x: x1, y: y1 };
      let t = ((px - x1)*dx + (py - y1)*dy) / len2;
      t = Math.max(0, Math.min(1, t));
      return { x: x1 + t*dx, y: y1 + t*dy };
    }

    // ------------------------------
    //     GAME INITIALIZATION
    // ------------------------------
    function initGame() {
      GameState.stations.clear();
      GameState.destinations.clear();
      GameState.roadSegments.clear();
      GameState.intersections.clear();
      GameState.cars.clear();
      GameState.nextStationID = 1;
      GameState.nextDestinationID = 1;
      GameState.nextSegmentID = 1;
      GameState.nextIntersectionID = 1;
      GameState.nextCarID = 1;
      GameState.score = 0;
      GameState.totalWaitTime = 0;
      GameState.deliveredCount = 0;
      GameState.week = 1;
      GameState.month = 1;
      GameState.isGameOver = false;
      GameState.isPaused = false;
      GameState.tokens = 2;
      GameState.selectedResource = null;
      GameState.selectedNode = null;
      GameState.previewLine = null;
      GameState.mousePos = { x:0, y:0 };

      stationSpawnTimer = 0;
      destinationSpawnTimer = 0;
      passengerSpawnTimer = 0;
      weekTimer = 0;

      // Spawn initial nodes
      for (let i = 0; i < 3; i++) spawnStation();
      for (let i = 0; i < 2; i++) spawnDestination();

      updateUI();
      updateTooltip('Click a node and drag to build roads.');
    }

    window.addEventListener('DOMContentLoaded', () => {
      resizeCanvas();
      initGame();
      document.getElementById('guideModal').classList.add('show');
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    });
  </script>
</body>
</html>
