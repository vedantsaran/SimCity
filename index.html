<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aetherbound: Turn of Echoes</title>
    <style>
        /* ============================================
           GLOBAL STYLES
        ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            color: #e0e6ed;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            height: 100vh;
        }

        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-bottom: 2px solid #4a90e2;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title {
            font-size: 18px;
            color: #4a90e2;
            text-shadow: 0 0 10px #4a90e2;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .hp { color: #e74c3c; }
        .ae { color: #3498db; }
        .ap { color: #f39c12; }

        .game-board {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(15, 30px);
            grid-template-rows: repeat(15, 30px);
            gap: 1px;
            background: #2c3e50;
            padding: 5px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.3);
        }

        .tile {
            width: 30px;
            height: 30px;
            border: 1px solid #34495e;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .tile:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        .floor {
            background: #34495e;
        }

        .wall {
            background: #2c3e50;
            color: #7f8c8d;
        }

        .player {
            background: radial-gradient(circle, #4a90e2, #2980b9);
            color: white;
            text-shadow: 0 0 5px #4a90e2;
            box-shadow: 0 0 10px #4a90e2;
        }

        .enemy {
            background: radial-gradient(circle, #e74c3c, #c0392b);
            color: white;
            text-shadow: 0 0 5px #e74c3c;
            box-shadow: 0 0 10px #e74c3c;
        }

        .trap {
            background: #8e44ad;
            color: #ecf0f1;
        }

        .hazard-fire {
            background: rgba(255, 100, 0, 0.6) !important;
        }

        .hazard-slow {
            background: rgba(0, 100, 255, 0.6) !important;
        }

        .highlight {
            background: rgba(241, 196, 15, 0.5) !important;
            border: 2px solid #f1c40f;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border-left: 2px solid #4a90e2;
            padding: 20px;
            overflow-y: auto;
        }

        .section {
            margin-bottom: 20px;
            background: rgba(52, 73, 94, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4a90e2;
        }

        .section h3 {
            color: #4a90e2;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid #4a90e2;
            padding-bottom: 5px;
        }

        .abilities {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .ability {
            background: rgba(74, 144, 226, 0.2);
            border: 1px solid #4a90e2;
            color: white;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        .ability:hover {
            background: rgba(74, 144, 226, 0.4);
            transform: translateY(-2px);
        }

        .ability.disabled {
            background: rgba(127, 140, 141, 0.3);
            color: #95a5a6;
            cursor: not-allowed;
        }

        .ability.disabled:hover {
            transform: none;
        }

        .turn-order {
            max-height: 200px;
            overflow-y: auto;
        }

        .turn-item {
            padding: 5px;
            margin: 2px 0;
            border-radius: 4px;
            font-size: 12px;
        }

        .turn-player {
            background: rgba(74, 144, 226, 0.3);
            border-left: 3px solid #4a90e2;
        }

        .turn-enemy {
            background: rgba(231, 76, 60, 0.3);
            border-left: 3px solid #e74c3c;
        }

        .controls {
            text-align: center;
            margin-top: 10px;
        }

        .btn {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #357abd;
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
        }

        .log {
            background: rgba(0, 0, 0, 0.8);
            height: 150px;
            overflow-y: auto;
            padding: 10px;
            font-size: 12px;
            border: 1px solid #4a90e2;
            border-radius: 4px;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px;
        }

        .log-player { color: #4a90e2; }
        .log-enemy { color: #e74c3c; }
        .log-system { color: #f39c12; }

        .class-selection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .class-modal {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #4a90e2;
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
            max-width: 600px;
            text-align: center;
        }

        .class-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .class-card {
            background: rgba(74, 144, 226, 0.1);
            border: 2px solid #4a90e2;
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .class-card:hover {
            background: rgba(74, 144, 226, 0.3);
            transform: scale(1.05);
        }

        .class-name {
            font-size: 18px;
            color: #4a90e2;
            margin-bottom: 10px;
        }

        .class-desc {
            font-size: 12px;
            color: #bdc3c7;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 200px;
                order: -1;
            }
            
            .grid {
                grid-template-columns: repeat(15, 20px);
                grid-template-rows: repeat(15, 20px);
            }
            
            .tile {
                width: 20px;
                height: 20px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Class Selection Modal -->
    <div id="classSelection" class="class-selection">
        <div class="class-modal">
            <h2 style="color: #4a90e2; margin-bottom: 20px;">Choose Your Shard Class</h2>
            <div class="class-grid">
                <div class="class-card" onclick="selectClass('vanguard')">
                    <div class="class-name">Celestial Vanguard</div>
                    <div class="class-desc">Tank/Support ‚Äì Solar shields and radiant attacks</div>
                </div>
                <div class="class-card" onclick="selectClass('reaver')">
                    <div class="class-name">Umbral Reaver</div>
                    <div class="class-desc">Assassin/Control ‚Äì Shadow teleports and stealth</div>
                </div>
                <div class="class-card" onclick="selectClass('mage')">
                    <div class="class-name">Aether Mage</div>
                    <div class="class-desc">Mage/Control ‚Äì Elemental storms and shields</div>
                </div>
                <div class="class-card" onclick="selectClass('tinkerer')">
                    <div class="class-name">Chrono Tinkerer</div>
                    <div class="class-desc">Controller/Utility ‚Äì Time manipulation and gadgets</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Game Container -->
    <div class="game-container">
        <!-- Main Area: Header + Board -->
        <div class="main-area">
            <!-- Header: Title & Stats -->
            <div class="header">
                <div class="title">Aetherbound: Turn of Echoes</div>
                <div class="stats">
                    <div class="stat hp">‚ù§Ô∏è HP: <span id="playerHp">0</span>/<span id="playerMaxHp">0</span></div>
                    <div class="stat ae">‚ö° AE: <span id="playerAe">0</span>/<span id="playerMaxAe">0</span></div>
                    <div class="stat ap">üî• AP: <span id="playerAp">0</span></div>
                </div>
            </div>
            
            <!-- Game Board: 15√ó15 Grid -->
            <div class="game-board">
                <div id="gameGrid" class="grid"></div>
            </div>
        </div>

        <!-- Sidebar: Abilities, Turn Order, Controls, Log -->
        <div class="sidebar">
            <!-- Abilities Section -->
            <div class="section">
                <h3>Abilities</h3>
                <div id="abilities" class="abilities"></div>
            </div>

            <!-- Turn Order Section -->
            <div class="section">
                <h3>Turn Order</h3>
                <div id="turnOrder" class="turn-order"></div>
            </div>

            <!-- Controls Section -->
            <div class="section">
                <h3>Controls</h3>
                <div class="controls">
                    <button class="btn" onclick="endTurn()" id="endTurnBtn">End Turn</button>
                    <button class="btn" onclick="meditate()" id="meditateBtn">Meditate</button>
                </div>
            </div>

            <!-- Action Log Section -->
            <div class="section">
                <h3>Action Log</h3>
                <div id="actionLog" class="log"></div>
            </div>
        </div>
    </div>

    <script>
        /******************************************
         *           GAME STATE & DATA
        *******************************************/
        const gameState = {
            player: null,
            enemies: [],
            grid: [],
            turnQueue: [],
            currentTurnIndex: 0,
            selectedAbilityIndex: null,
            highlightedTiles: [],
            chamber: 1,
            gamePhase: 'init', // 'init', 'player', 'enemy'
            logMaxEntries: 100
        };

        // Class & Ability Definitions
        const classes = {
            vanguard: {
                name: "Celestial Vanguard",
                baseHp: 120,
                baseAe: 10,
                baseAp: 4,
                initiative: 5,
                symbol: "V",
                abilities: [
                    {
                        name: "Solar Aegis",
                        cost: { ap: 2, ae: 3 },
                        cooldownMax: 3,
                        currentCooldown: 0,
                        description: "Shield self for 2 turns (absorb 15 dmg).",
                        type: "self"
                    },
                    {
                        name: "Radiant Flare",
                        cost: { ap: 2, ae: 4 },
                        cooldownMax: 4,
                        currentCooldown: 0,
                        description: "3√ó3 AoE: 20 damage + blinds 1 turn.",
                        type: "aoe"
                    },
                    {
                        name: "Basic Attack",
                        cost: { ap: 1, ae: 0 },
                        cooldownMax: 0,
                        currentCooldown: 0,
                        description: "Strike adjacent enemy.",
                        type: "attack"
                    }
                ]
            },
            reaver: {
                name: "Umbral Reaver",
                baseHp: 80,
                baseAe: 12,
                baseAp: 5,
                initiative: 7,
                symbol: "R",
                abilities: [
                    {
                        name: "Void Slash",
                        cost: { ap: 1, ae: 3 },
                        cooldownMax: 2,
                        currentCooldown: 0,
                        description: "Melee + teleport behind if possible.",
                        type: "attack"
                    },
                    {
                        name: "Shadowmeld",
                        cost: { ap: 2, ae: 5 },
                        cooldownMax: 4,
                        currentCooldown: 0,
                        description: "Invisible 2 turns, next attack crit.",
                        type: "self"
                    },
                    {
                        name: "Basic Attack",
                        cost: { ap: 1, ae: 0 },
                        cooldownMax: 0,
                        currentCooldown: 0,
                        description: "Strike adjacent enemy.",
                        type: "attack"
                    }
                ]
            },
            mage: {
                name: "Aether Mage",
                baseHp: 70,
                baseAe: 15,
                baseAp: 3,
                initiative: 6,
                symbol: "M",
                abilities: [
                    {
                        name: "Blazing Tempest",
                        cost: { ap: 3, ae: 6 },
                        cooldownMax: 4,
                        currentCooldown: 0,
                        description: "Fire tornado in 3√ó3 for 2 turns (15 dmg).",
                        type: "aoe"
                    },
                    {
                        name: "Mana Bolt",
                        cost: { ap: 1, ae: 2 },
                        cooldownMax: 0,
                        currentCooldown: 0,
                        description: "Ranged 3-tile magic attack (15 dmg).",
                        type: "ranged"
                    },
                    {
                        name: "Basic Attack",
                        cost: { ap: 1, ae: 0 },
                        cooldownMax: 0,
                        currentCooldown: 0,
                        description: "Staff melee strike.",
                        type: "attack"
                    }
                ]
            },
            tinkerer: {
                name: "Chrono Tinkerer",
                baseHp: 90,
                baseAe: 12,
                baseAp: 4,
                initiative: 4,
                symbol: "T",
                abilities: [
                    {
                        name: "Flux Grenade",
                        cost: { ap: 1, ae: 3 },
                        cooldownMax: 3,
                        currentCooldown: 0,
                        description: "Place slow grenade (2-tile radius, 2 turns).",
                        type: "ranged"
                    },
                    {
                        name: "Temporal Loop",
                        cost: { ap: 3, ae: 8 },
                        cooldownMax: 5,
                        currentCooldown: 0,
                        description: "Echo last 2 actions next enemy phase.",
                        type: "utility"
                    },
                    {
                        name: "Basic Attack",
                        cost: { ap: 1, ae: 0 },
                        cooldownMax: 0,
                        currentCooldown: 0,
                        description: "Gadget punch.",
                        type: "attack"
                    }
                ]
            }
        };

        // Enemy Type Definitions
        const enemyTypes = {
            guardian: {
                name: "Temple Guardian",
                hp: 50,
                initiative: 5,
                symbol: "G",
                ai: "defensive"
            },
            walker: {
                name: "Spore Walker",
                hp: 30,
                initiative: 7,
                symbol: "W",
                ai: "aggressive"
            },
            sentinel: {
                name: "Molten Sentinel",
                hp: 60,
                initiative: 4,
                symbol: "S",
                ai: "patrol"
            }
        };

        // Hazard Definitions
        class Hazard {
            constructor(x, y, config) {
                this.x = x;
                this.y = y;
                this.type = config.type;         // 'fire' or 'slow'
                this.duration = config.duration; // number of turns
                this.timer = config.timer || 0;  // for delayed detonations
                this.value = config.value || 0;  // damage or slow %
                this.radius = config.radius || 0; // for area effects
            }
        }

        // Add basic utility functions
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function distance(ax, ay, bx, by) {
            return Math.abs(ax - bx) + Math.abs(ay - by);
        }

        /******************************************
         *        CLASS SELECTION & INIT
        *******************************************/
        function selectClass(classKey) {
            const cls = classes[classKey];
            gameState.player = {
                x: 7,
                y: 7,
                classKey: classKey,
                name: cls.name,
                hp: cls.baseHp,
                maxHp: cls.baseHp,
                ae: cls.baseAe,
                maxAe: cls.baseAe,
                ap: cls.baseAp,
                maxAp: cls.baseAp,
                initiative: cls.initiative,
                symbol: cls.symbol,
                abilities: cls.abilities.map(a => ({ ...a, currentCooldown: 0 })),
                effects: [],    // { type: 'shield'|'invisible'|'blind'|'slow'|'stun', duration: n, value: x }
                history: []     // record last 2 actions for Temporal Loop
            };

            document.getElementById('classSelection').style.display = 'none';
            startNewGame();
        }

        /******************************************
         *          GAME INITIALIZATION
        *******************************************/
        function startNewGame() {
            generateGrid();
            placePlayer();
            spawnEnemies();
            gameState.hazards = [];
            gameState.chamber = 1;
            calculateTurnOrder();
            gameState.gamePhase = 'player';
            updateUI();
            renderGrid();
            addLogEntry("system", `${gameState.player.name} enters Chamber ${gameState.chamber}.`);
        }

        function generateGrid() {
            gameState.grid = [];
            for (let y = 0; y < 15; y++) {
                gameState.grid[y] = [];
                for (let x = 0; x < 15; x++) {
                    let type = 'floor';
                    if (Math.random() < 0.1) type = 'wall';
                    else if (Math.random() < 0.05) type = 'trap';
                    gameState.grid[y][x] = {
                        type: type,
                        entity: null,
                        hazards: [] // array of Hazard objects
                    };
                }
            }
            // Ensure starting position is floor
            gameState.grid[7][7].type = 'floor';
        }

        function placePlayer() {
            gameState.grid[gameState.player.y][gameState.player.x].entity = 'player';
        }

        function spawnEnemies() {
            gameState.enemies = [];
            const count = 3 + gameState.chamber; // increase by chamber
            for (let i = 0; i < count; i++) {
                let x, y;
                do {
                    x = getRandomInt(0, 14);
                    y = getRandomInt(0, 14);
                } while (
                    gameState.grid[y][x].type !== 'floor' ||
                    gameState.grid[y][x].entity !== null ||
                    (Math.abs(x - gameState.player.x) <= 2 && Math.abs(y - gameState.player.y) <= 2)
                );
                const typeKeys = Object.keys(enemyTypes);
                const et = enemyTypes[typeKeys[getRandomInt(0, typeKeys.length - 1)]];
                const enemy = {
                    id: i,
                    x: x,
                    y: y,
                    name: et.name,
                    hp: et.hp,
                    maxHp: et.hp,
                    initiative: et.initiative,
                    symbol: et.symbol,
                    ai: et.ai,
                    ap: 2,
                    maxAp: 2,
                    effects: [] // same structure as player.effects
                };
                gameState.enemies.push(enemy);
                gameState.grid[y][x].entity = enemy;
            }
        }

        /******************************************
         *          TURN ORDER CALCULATION
        *******************************************/
        function calculateTurnOrder() {
            gameState.turnQueue = [];

            // Add player
            gameState.turnQueue.push({
                type: 'player',
                initiative: gameState.player.initiative + Math.random(),
                entity: gameState.player
            });

            // Add enemies
            gameState.enemies.forEach(en => {
                gameState.turnQueue.push({
                    type: 'enemy',
                    initiative: en.initiative + Math.random(),
                    entity: en
                });
            });

            // Sort ascending (lower acts first)
            gameState.turnQueue.sort((a, b) => a.initiative - b.initiative);
            gameState.currentTurnIndex = 0;
        }

        /******************************************
         *         GRID RENDERING LOGIC
        *******************************************/
        function renderGrid() {
            const gridEl = document.getElementById('gameGrid');
            gridEl.innerHTML = '';

            for (let y = 0; y < 15; y++) {
                for (let x = 0; x < 15; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('tile');
                    cell.classList.add(gameState.grid[y][x].type);

                    // Highlight if needed
                    if (gameState.highlightedTiles.some(t => t.x === x && t.y === y)) {
                        cell.classList.add('highlight');
                    }

                    // Draw hazards (fire or slow)
                    gameState.grid[y][x].hazards.forEach(h => {
                        if (h.type === 'fire') {
                            cell.classList.add('hazard-fire');
                        } else if (h.type === 'slow') {
                            cell.classList.add('hazard-slow');
                        }
                    });

                    // Draw entity
                    const ent = gameState.grid[y][x].entity;
                    if (ent === 'player') {
                        cell.classList.add('player');
                        cell.textContent = gameState.player.symbol;
                    } else if (ent && typeof ent === 'object') {
                        cell.classList.add('enemy');
                        cell.textContent = ent.symbol;
                    } else if (gameState.grid[y][x].type === 'wall') {
                        cell.textContent = '#';
                    } else if (gameState.grid[y][x].type === 'trap') {
                        cell.textContent = '^';
                    }

                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', () => handleTileClick(x, y));
                    gridEl.appendChild(cell);
                }
            }
            updateTurnOrderUI();
        }

        /******************************************
         *      PLAYER CLICK / MOVE / ATTACK
        *******************************************/
        function handleTileClick(x, y) {
            if (gameState.gamePhase !== 'player') return;
            // If selecting ability
            if (gameState.selectedAbilityIndex !== null) {
                attemptUseAbility(gameState.selectedAbilityIndex, x, y);
                return;
            }
            // Otherwise attempt move or basic attack if adjacent
            const px = gameState.player.x;
            const py = gameState.player.y;
            const dist = distance(px, py, x, y);

            if (dist === 1 && gameState.grid[y][x].entity && gameState.grid[y][x].entity !== 'player') {
                // Adjacent enemy: basic attack
                if (gameState.player.ap >= 1) {
                    basicAttack(x, y);
                } else {
                    addLogEntry("system", "Not enough AP to attack!");
                }
            } else {
                // Attempt move
                if (dist <= gameState.player.ap && canStand(x, y)) {
                    movePlayer(x, y);
                } else {
                    addLogEntry("system", "Cannot move there!");
                }
            }
        }

        function canStand(x, y) {
            if (x < 0 || x > 14 || y < 0 || y > 14) return false;
            if (gameState.grid[y][x].type === 'wall') return false;
            if (gameState.grid[y][x].entity && gameState.grid[y][x].entity !== 'player') return false;
            return true;
        }

        function movePlayer(x, y) {
            const px = gameState.player.x;
            const py = gameState.player.y;
            const dist = distance(px, py, x, y);

            gameState.grid[py][px].entity = null;
            gameState.player.x = x;
            gameState.player.y = y;
            gameState.grid[y][x].entity = 'player';
            gameState.player.ap -= dist;

            // Check trap
            if (gameState.grid[y][x].type === 'trap') {
                gameState.player.hp -= 10;
                addLogEntry("player", "Stepped on a trap. -10 HP!");
            }

            // Record move in history
            recordPlayerAction({ type: 'move', x: x, y: y });

            addLogEntry("player", `Moved to (${x}, ${y}). AP: ${gameState.player.ap}.`);
            updateUI();
            renderGrid();
        }

        function basicAttack(x, y) {
            const target = gameState.grid[y][x].entity;
            if (!target || typeof target !== 'object') {
                addLogEntry("system", "No enemy to attack!");
                return;
            }
            const dmg = 15 + getRandomInt(0, 5);
            target.hp -= dmg;
            addLogEntry("player", `Basic Attack: Hit ${target.name} for ${dmg} HP.`);

            if (target.hp <= 0) {
                killEnemy(target);
            }
            gameState.player.ap -= 1;

            recordPlayerAction({ type: 'attack', x: x, y: y });

            updateUI();
            renderGrid();
        }

        /******************************************
         *           ABILITY SELECTION UI
        *******************************************/
        function updateUI() {
            // Update stats
            document.getElementById('playerHp').textContent = gameState.player.hp;
            document.getElementById('playerMaxHp').textContent = gameState.player.maxHp;
            document.getElementById('playerAe').textContent = gameState.player.ae;
            document.getElementById('playerMaxAe').textContent = gameState.player.maxAe;
            document.getElementById('playerAp').textContent = gameState.player.ap;

            // Update abilities
            const abilitiesEl = document.getElementById('abilities');
            abilitiesEl.innerHTML = '';
            gameState.player.abilities.forEach((ab, idx) => {
                const btn = document.createElement('div');
                btn.classList.add('ability');
                if (
                    gameState.player.ap < ab.cost.ap ||
                    gameState.player.ae < ab.cost.ae ||
                    ab.currentCooldown > 0 ||
                    gameState.gamePhase !== 'player'
                ) {
                    btn.classList.add('disabled');
                }
                btn.textContent = `${ab.name} [AP:${ab.cost.ap} AE:${ab.cost.ae}] CD:${ab.currentCooldown}/${ab.cooldownMax}`;
                btn.title = ab.description;
                btn.addEventListener('click', () => {
                    if (gameState.gamePhase !== 'player') return;
                    if (gameState.player.ap < ab.cost.ap || gameState.player.ae < ab.cost.ae || ab.currentCooldown > 0) return;
                    selectAbility(idx);
                });
                abilitiesEl.appendChild(btn);
            });
        }

        function selectAbility(abilityIndex) {
            gameState.selectedAbilityIndex = abilityIndex;
            const ab = gameState.player.abilities[abilityIndex];
            gameState.highlightedTiles = [];

            const px = gameState.player.x;
            const py = gameState.player.y;

            if (ab.type === 'attack') {
                // Highlight adjacent tiles
                const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
                dirs.forEach(([dx,dy]) => {
                    const nx = px + dx, ny = py + dy;
                    if (nx >= 0 && nx < 15 && ny >= 0 && ny < 15) {
                        gameState.highlightedTiles.push({ x: nx, y: ny });
                    }
                });
            } else if (ab.type === 'ranged') {
                // Range 3
                for (let dx = -3; dx <= 3; dx++) {
                    for (let dy = -3; dy <= 3; dy++) {
                        const nx = px + dx, ny = py + dy;
                        if (nx >= 0 && nx < 15 && ny >= 0 && ny < 15 && !(dx === 0 && dy === 0)) {
                            if (distance(px, py, nx, ny) <= 3) {
                                gameState.highlightedTiles.push({ x: nx, y: ny });
                            }
                        }
                    }
                }
            } else if (ab.type === 'aoe') {
                // 3√ó3 centered on player
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const nx = px + dx, ny = py + dy;
                        if (nx >= 0 && nx < 15 && ny >= 0 && ny < 15) {
                            gameState.highlightedTiles.push({ x: nx, y: ny });
                        }
                    }
                }
            } else if (ab.type === 'utility') {
                // Self-target: no highlight needed
                gameState.highlightedTiles = [];
                attemptUseAbility(abilityIndex, px, py);
                return;
            }

            renderGrid();
            addLogEntry("system", `Selected ability: ${ab.name}. Click a highlighted tile.`);
        }

        function attemptUseAbility(idx, tx, ty) {
            const ab = gameState.player.abilities[idx];
            const px = gameState.player.x;
            const py = gameState.player.y;

            // Check if target is in highlightedTiles
            const valid = gameState.highlightedTiles.some(t => t.x === tx && t.y === ty) || ab.type === 'utility';
            if (!valid) {
                addLogEntry("system", `Invalid target for ${ab.name}.`);
                gameState.highlightedTiles = [];
                gameState.selectedAbilityIndex = null;
                renderGrid();
                return;
            }

            // Pay costs
            gameState.player.ap -= ab.cost.ap;
            gameState.player.ae -= ab.cost.ae;
            ab.currentCooldown = ab.cooldownMax;

            // Execute based on ability name
            switch (ab.name) {
                case "Solar Aegis":
                    solarAegis();
                    break;
                case "Radiant Flare":
                    radiantFlare(tx, ty);
                    break;
                case "Void Slash":
                    voidSlash(tx, ty);
                    break;
                case "Shadowmeld":
                    shadowmeld();
                    break;
                case "Blazing Tempest":
                    blazingTempest(px, py);
                    break;
                case "Mana Bolt":
                    manaBolt(tx, ty);
                    break;
                case "Flux Grenade":
                    fluxGrenade(tx, ty);
                    break;
                case "Temporal Loop":
                    temporalLoop();
                    break;
            }

            // Record history (move or attack)
            recordPlayerAction({ type: ab.type, x: tx, y: ty, name: ab.name });

            gameState.highlightedTiles = [];
            gameState.selectedAbilityIndex = null;
            updateUI();
            renderGrid();
        }

        /******************************************
         *         ABILITY IMPLEMENTATIONS
        *******************************************/
        function solarAegis() {
            gameState.player.effects.push({
                type: 'shield',
                duration: 2,
                value: 15
            });
            addLogEntry("player", "Solar Aegis: Shield for 2 turns (absorb 15 dmg each).");
        }

        function radiantFlare(cx, cy) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const x = cx + dx, y = cy + dy;
                    if (x < 0 || x > 14 || y < 0 || y > 14) continue;
                    const ent = gameState.grid[y][x].entity;
                    if (ent && typeof ent === 'object') {
                        const dmg = 20 + getRandomInt(0, 10);
                        ent.hp -= dmg;
                        addLogEntry("player", `Radiant Flare hit ${ent.name} for ${dmg} HP.`);
                        ent.effects.push({ type: 'blind', duration: 1, value: null });
                        if (ent.hp <= 0) killEnemy(ent);
                    }
                }
            }
        }

        function voidSlash(tx, ty) {
            const target = gameState.grid[ty][tx].entity;
            if (!target || typeof target !== 'object') {
                addLogEntry("system", "No target for Void Slash!");
                return;
            }
            const dmg = 25 + getRandomInt(0, 5);
            target.hp -= dmg;
            addLogEntry("player", `Void Slash: Hit ${target.name} for ${dmg} HP.`);
            if (target.hp <= 0) {
                killEnemy(target);
            }
            // Attempt teleport behind
            const px = gameState.player.x;
            const py = gameState.player.y;
            const dx = tx - px;
            const dy = ty - py;
            const nx = tx + dx;
            const ny = ty + dy;
            if (nx >= 0 && nx < 15 && ny >= 0 && ny < 15 && canStand(nx, ny)) {
                gameState.grid[py][px].entity = null;
                gameState.player.x = nx;
                gameState.player.y = ny;
                gameState.grid[ny][nx].entity = 'player';
                addLogEntry("player", `Teleported to (${nx}, ${ny}).`);
            }
        }

        function shadowmeld() {
            gameState.player.effects.push({
                type: 'invisible',
                duration: 2,
                value: null
            });
            addLogEntry("player", "Shadowmeld: Invisible for 2 turns. Next attack is a crit.");
        }

        function blazingTempest(cx, cy) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const x = cx + dx, y = cy + dy;
                    if (x < 0 || x > 14 || y < 0 || y > 14) continue;
                    const hz = new Hazard(x, y, { type: 'fire', duration: 2, value: 15 });
                    gameState.grid[y][x].hazards.push(hz);
                }
            }
            addLogEntry("player", "Blazing Tempest: Centered fiery zone for 2 turns.");
        }

        function manaBolt(tx, ty) {
            const target = gameState.grid[ty][tx].entity;
            if (!target || typeof target !== 'object') {
                addLogEntry("system", "No target for Mana Bolt!");
                return;
            }
            const dmg = 15 + getRandomInt(0, 5);
            target.hp -= dmg;
            addLogEntry("player", `Mana Bolt: Hit ${target.name} for ${dmg} HP.`);
            if (target.hp <= 0) killEnemy(target);
        }

        function fluxGrenade(tx, ty) {
            const hz = new Hazard(tx, ty, { type: 'slow', timer: 1, duration: 2, radius: 2 });
            gameState.grid[ty][tx].hazards.push(hz);
            addLogEntry("player", `Flux Grenade placed at (${tx}, ${ty}), will detonate next enemy phase.`);
        }

        function temporalLoop() {
            // Simple implementation: heal 20 HP and reduce all ability cooldowns by 1
            gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 20);
            gameState.player.abilities.forEach(ab => {
                if (ab.currentCooldown > 0) ab.currentCooldown = Math.max(0, ab.currentCooldown - 1);
            });
            addLogEntry("player", "Temporal Loop: Healed 20 HP and reduced cooldowns by 1.");
        }

        function recordPlayerAction(action) {
            gameState.player.history.push(action);
            if (gameState.player.history.length > 2) {
                gameState.player.history.shift();
            }
        }

        /******************************************
         *         ENEMY TURN & AI LOGIC
        *******************************************/
        function processEnemyTurn() {
            gameState.enemies.forEach(en => {
                if (en.hp <= 0) return;
                // Decrement enemy AP and reset to maxAp
                en.ap = en.maxAp;

                // Decrement statuses
                en.effects = en.effects.filter(e => {
                    e.duration--;
                    return e.duration > 0;
                });

                // Skip if stunned
                if (en.effects.some(e => e.type === 'stun')) {
                    addLogEntry("enemy", `${en.name} is stunned and skips its turn.`);
                    return;
                }

                // If adjacent to player, attack
                const dist = distance(en.x, en.y, gameState.player.x, gameState.player.y);
                if (dist === 1) {
                    // Attack
                    if (en.ap >= 1) {
                        let dmg = 10 + getRandomInt(0, 5);
                        if (Math.random() < 0.1) dmg = Math.floor(dmg * 1.5);
                        applyDamageToPlayer(dmg);
                        addLogEntry("enemy", `${en.name} hits you for ${dmg} HP.`);
                        en.ap -= 1;
                    }
                } else {
                    // Move toward player
                    if (en.ap >= 1) {
                        const dx = gameState.player.x > en.x ? 1 : (gameState.player.x < en.x ? -1 : 0);
                        const dy = gameState.player.y > en.y ? 1 : (gameState.player.y < en.y ? -1 : 0);
                        const nx = en.x + dx;
                        const ny = en.y + dy;
                        if (canStand(nx, ny) && !isPlayerAt(nx, ny)) {
                            gameState.grid[en.y][en.x].entity = null;
                            en.x = nx;
                            en.y = ny;
                            gameState.grid[ny][nx].entity = en;
                            en.ap -= 1;
                            addLogEntry("enemy", `${en.name} moves to (${nx}, ${ny}).`);
                        }
                    }
                }

                // Trigger hazards on its tile
                triggerHazards(en.x, en.y, en, 'enemy');
            });
        }

        function applyDamageToPlayer(dmg) {
            // Check shield
            const shield = gameState.player.effects.find(e => e.type === 'shield');
            if (shield) {
                const absorbed = Math.min(shield.value, dmg);
                dmg -= absorbed;
                shield.value -= absorbed;
                if (shield.value <= 0) {
                    gameState.player.effects = gameState.player.effects.filter(e => e !== shield);
                }
                addLogEntry("system", `Shield absorbed ${absorbed} damage.`);
            }
            if (dmg > 0) {
                gameState.player.hp -= dmg;
            }
            updateUI();
            if (gameState.player.hp <= 0) {
                gameOver(false);
            }
        }

        function isPlayerAt(x, y) {
            return gameState.player.x === x && gameState.player.y === y;
        }

        /******************************************
         *        HAZARD & STATUS PROCESSING
        *******************************************/
        function processHazards() {
            // For each cell, process each hazard
            for (let y = 0; y < 15; y++) {
                for (let x = 0; x < 15; x++) {
                    const cell = gameState.grid[y][x];
                    for (let i = cell.hazards.length - 1; i >= 0; i--) {
                        const hz = cell.hazards[i];
                        if (hz.type === 'fire') {
                            // At start of each enemy phase and player turn, deal damage
                            if ( (gameState.gamePhase === 'enemy') || (gameState.gamePhase === 'player') ) {
                                // Damage any entity on this tile
                                if (isPlayerAt(x, y)) {
                                    applyDamageToPlayer(hz.value);
                                    addLogEntry("system", `Fire hazard burns you for ${hz.value} HP.`);
                                } else {
                                    const ent = cell.entity;
                                    if (ent && typeof ent === 'object') {
                                        ent.hp -= hz.value;
                                        addLogEntry("system", `${ent.name} is burned for ${hz.value} HP.`);
                                        if (ent.hp <= 0) killEnemy(ent);
                                    }
                                }
                            }
                            hz.duration--;
                            if (hz.duration <= 0) {
                                cell.hazards.splice(i, 1);
                            }
                        } else if (hz.type === 'slow') {
                            // Timer counts down first
                            if (hz.timer > 0) {
                                hz.timer--;
                            } else {
                                // Detonate: apply slow to enemies in radius
                                for (let dy = -hz.radius; dy <= hz.radius; dy++) {
                                    for (let dx = -hz.radius; dx <= hz.radius; dx++) {
                                        const tx = x + dx;
                                        const ty = y + dy;
                                        if (tx < 0 || tx > 14 || ty < 0 || ty > 14) continue;
                                        const ent = gameState.grid[ty][tx].entity;
                                        if (ent && typeof ent === 'object' && ent !== 'player') {
                                            ent.effects.push({ type: 'slow', duration: hz.duration, value: null });
                                            addLogEntry("system", `${ent.name} is slowed for ${hz.duration} turns.`);
                                        }
                                    }
                                }
                                cell.hazards.splice(i, 1);
                            }
                        }
                    }
                }
            }
        }

        function triggerHazards(x, y, entity, phase) {
            const cell = gameState.grid[y][x];
            cell.hazards.forEach(hz => {
                if (hz.type === 'fire' && (phase === 'player' || phase === 'enemy')) {
                    const dmg = hz.value;
                    if (entity === gameState.player) {
                        applyDamageToPlayer(dmg);
                        addLogEntry("system", `Fire hazard burns you for ${dmg} HP.`);
                    } else {
                        entity.hp -= dmg;
                        addLogEntry("system", `${entity.name} is burned for ${dmg} HP.`);
                        if (entity.hp <= 0) killEnemy(entity);
                    }
                }
            });
        }

        /******************************************
         *          END OF TURN PROCESSING
        *******************************************/
        function endTurn() {
            if (gameState.gamePhase !== 'player') return;
            gameState.gamePhase = 'enemy';

            // Decrement player abilities' cooldowns
            gameState.player.abilities.forEach(ab => {
                if (ab.currentCooldown > 0) ab.currentCooldown--;
            });

            // Process hazards at enemy phase start
            processHazards();

            // Process enemy turns
            processEnemyTurn();

            // Process hazards again (in case enemies walked into fire)
            processHazards();

            // After enemies, new round begins
            newRound();
        }

        function meditate() {
            if (gameState.gamePhase !== 'player') return;
            if (gameState.player.ap > 0) {
                addLogEntry("system", "Must spend all AP before meditating to regenerate AE.");
                return;
            }
            gameState.player.ae = Math.min(gameState.player.maxAe, gameState.player.ae + 2);
            addLogEntry("player", "Meditate: Regained 2 AE.");
            updateUI();
        }

        function newRound() {
            // Reset player AP
            gameState.player.ap = gameState.player.maxAp;

            // Regenerate 1 AE if no ability used last turn
            // Simple heuristic: if any ability cooldown was reduced, assume no skill cast
            gameState.player.ae = Math.min(gameState.player.maxAe, gameState.player.ae + 1);

            // Decrement player statuses
            gameState.player.effects = gameState.player.effects.filter(e => {
                e.duration--;
                return e.duration > 0;
            });

            // Reset enemies' AP
            gameState.enemies.forEach(en => {
                en.ap = en.maxAp;
                en.effects = en.effects.filter(e => {
                    e.duration--;
                    return e.duration > 0;
                });
            });

            // Check if all enemies are dead
            if (gameState.enemies.length === 0) {
                addLogEntry("system", `Chamber ${gameState.chamber} cleared! Advancing.`);
                advanceChamber();
                return;
            }

            gameState.gamePhase = 'player';
            calculateTurnOrder();
            updateUI();
            renderGrid();
        }

        function advanceChamber() {
            gameState.chamber++;
            if (gameState.chamber > 5) {
                gameOver(true);
                return;
            }
            // Clear grid, hazards, reposition player
            generateGrid();
            gameState.player.x = 7;
            gameState.player.y = 7;
            placePlayer();
            spawnEnemies();
            gameState.hazards = [];
            calculateTurnOrder();
            gameState.gamePhase = 'player';
            updateUI();
            renderGrid();
            addLogEntry("system", `Entering Chamber ${gameState.chamber}.`);
        }

        /******************************************
         *          ENEMY DEFEAT & GAME OVER
        *******************************************/
        function killEnemy(enemy) {
            gameState.grid[enemy.y][enemy.x].entity = null;
            gameState.enemies = gameState.enemies.filter(e => e !== enemy);
            addLogEntry("system", `${enemy.name} defeated.`);
        }

        function gameOver(victory) {
            gameState.gamePhase = 'ended';
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'rgba(0,0,0,0.9)';
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            overlay.style.zIndex = '2000';

            const modal = document.createElement('div');
            modal.style.background = '#1a1f3a';
            modal.style.padding = '30px';
            modal.style.borderRadius = '10px';
            modal.style.border = '2px solid #4a90e2';
            modal.style.textAlign = 'center';
            modal.style.color = '#e0e6ed';
            modal.style.boxShadow = '0 0 30px rgba(74,144,226,0.5)';

            const title = document.createElement('h1');
            title.textContent = victory ? "Victory!" : "Game Over";
            title.style.color = victory ? "#2ecc71" : "#e74c3c";
            title.style.marginBottom = '20px';

            const msg = document.createElement('p');
            msg.textContent = victory ?
                "You have conquered the Endless Abyss!" :
                "Your Wardenship ends here.";
            msg.style.marginBottom = '20px';

            const btn = document.createElement('button');
            btn.textContent = "Restart";
            btn.classList.add('btn');
            btn.addEventListener('click', () => {
                location.reload();
            });

            modal.appendChild(title);
            modal.appendChild(msg);
            modal.appendChild(btn);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }

        /******************************************
         *           TURN ORDER UI UPDATE
        *******************************************/
        function updateTurnOrderUI() {
            const el = document.getElementById('turnOrder');
            el.innerHTML = '';

            gameState.turnQueue.forEach((turn, idx) => {
                const item = document.createElement('div');
                item.classList.add('turn-item');
                if (idx === gameState.currentTurnIndex) {
                    if (turn.type === 'player') item.classList.add('turn-player');
                    else item.classList.add('turn-enemy');
                }
                if (turn.type === 'player') {
                    item.textContent = `You (HP:${gameState.player.hp})`;
                } else {
                    const en = turn.entity;
                    item.textContent = `${en.name} (HP:${en.hp})`;
                }
                el.appendChild(item);
            });
        }

        /******************************************
         *             ACTION LOGGING
        *******************************************/
        function addLogEntry(who, text) {
            const logEl = document.getElementById('actionLog');
            const entry = document.createElement('div');
            entry.classList.add('log-entry');

            if (who === 'player') entry.classList.add('log-player');
            else if (who === 'enemy') entry.classList.add('log-enemy');
            else entry.classList.add('log-system');

            entry.textContent = text;
            logEl.appendChild(entry);

            // Trim overflow
            while (logEl.children.length > gameState.logMaxEntries) {
                logEl.removeChild(logEl.firstChild);
            }
            logEl.scrollTop = logEl.scrollHeight;
        }

        /******************************************
         *         INITIAL GAME SETUP CALL
        *******************************************/
        window.onload = () => {
            // Nothing to do until class is selected
        };

        /******************************************
         *        KEYBOARD SHORTCUTS (Optional)
        *******************************************/
        window.addEventListener('keydown', e => {
            if (gameState.gamePhase !== 'player') return;
            const key = e.key;
            const px = gameState.player.x;
            const py = gameState.player.y;

            if (key === 'ArrowUp' || key === 'w') {
                const nx = px, ny = py - 1;
                if (distance(px, py, nx, ny) === 1 && canStand(nx, ny) && gameState.player.ap >= 1) {
                    movePlayer(nx, ny);
                }
            } else if (key === 'ArrowDown' || key === 's') {
                const nx = px, ny = py + 1;
                if (distance(px, py, nx, ny) === 1 && canStand(nx, ny) && gameState.player.ap >= 1) {
                    movePlayer(nx, ny);
                }
            } else if (key === 'ArrowLeft' || key === 'a') {
                const nx = px - 1, ny = py;
                if (distance(px, py, nx, ny) === 1 && canStand(nx, ny) && gameState.player.ap >= 1) {
                    movePlayer(nx, ny);
                }
            } else if (key === 'ArrowRight' || key === 'd') {
                const nx = px + 1, ny = py;
                if (distance(px, py, nx, ny) === 1 && canStand(nx, ny) && gameState.player.ap >= 1) {
                    movePlayer(nx, ny);
                }
            } else if (key === ' ') {
                // Basic attack in one of four directions if enemy present
                // Prioritize up, right, down, left in that order
                const dirs = [
                    [0, -1],
                    [1, 0],
                    [0, 1],
                    [-1, 0]
                ];
                for (let [dx, dy] of dirs) {
                    const tx = px + dx, ty = py + dy;
                    if (tx >= 0 && tx < 15 && ty >= 0 && ty < 15) {
                        if (gameState.grid[ty][tx].entity && typeof gameState.grid[ty][tx].entity === 'object' && gameState.player.ap >= 1) {
                            basicAttack(tx, ty);
                            break;
                        }
                    }
                }
            } else if (['1','2','3','4'].includes(key)) {
                const idx = parseInt(key) - 1;
                if (idx < gameState.player.abilities.length) {
                    const ab = gameState.player.abilities[idx];
                    if (gameState.player.ap >= ab.cost.ap && gameState.player.ae >= ab.cost.ae && ab.currentCooldown === 0) {
                        selectAbility(idx);
                    }
                }
            } else if (key.toLowerCase() === 'e') {
                endTurn();
            } else if (key.toLowerCase() === 'm') {
                meditate();
            }
        });
    </script>
</body>
</html>
