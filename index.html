```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Scale Clone - Browser Edition</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #gameCanvas {
      background: #222;
      border: 2px solid #444;
      display: block;
      touch-action: none; /* prevent default touch scrolling */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- Clipper.js via CDN for polygon clipping -->
  <script src="https://unpkg.com/js-clipper@6.4.2/clipper.js"></script>
  <script>
    // ==== GLOBAL GAME STATE ====
    const GAME = {
      width: 800,
      height: 600,
      canvas: null,
      ctx: null,
      lastTimestamp: 0,
      playfield: [],        // current polygon (array of {x,y})
      balls: [],            // array of {x,y,vx,vy,radius}
      slice: null,          // {start:{x,y}, end:{x,y}}
      isCutting: false,
      isAnimating: false,
      level: 0,
      lives: 3,
      targetPercent: 70,    // percentage to cut this level
      initialArea: 1,
      remainingArea: 1,
    };

    // ==== UTILITY FUNCTIONS ====
    function polygonArea(poly) {
      let area = 0;
      for (let i = 0; i < poly.length; i++) {
        const a = poly[i];
        const b = poly[(i + 1) % poly.length];
        area += a.x * b.y - b.x * a.y;
      }
      return Math.abs(area) / 2;
    }

    function toClipper(subjectPolygons) {
      // convert [[{x,y},...],...] → [[{X,Y},...],...], scaled by 1000
      return subjectPolygons.map(poly =>
        poly.map(pt => ({ X: Math.round(pt.x * 1000), Y: Math.round(pt.y * 1000) }))
      );
    }

    function fromClipper(clipperPolygons) {
      // convert [[{X,Y},...],...] → [[{x,y},...],...]
      return clipperPolygons.map(poly =>
        poly.map(pt => ({ x: pt.X / 1000, y: pt.Y / 1000 }))
      );
    }

    function keepLargest(polygons) {
      let maxArea = -Infinity, idx = 0;
      for (let i = 0; i < polygons.length; i++) {
        const a = polygonArea(polygons[i]);
        if (a > maxArea) {
          maxArea = a;
          idx = i;
        }
      }
      return polygons[idx];
    }

    function getEdges(polygon) {
      const edges = [];
      for (let i = 0; i < polygon.length; i++) {
        const a = polygon[i];
        const b = polygon[(i + 1) % polygon.length];
        edges.push({ a, b });
      }
      return edges;
    }

    function reflectBall(ball, edge) {
      const { a, b } = edge;
      const ex = b.x - a.x;
      const ey = b.y - a.y;
      const len = Math.hypot(ex, ey);
      if (len === 0) return;
      const ux = ex / len;
      const uy = ey / len;
      const nx = -uy, ny = ux;
      const dot = ball.vx * nx + ball.vy * ny;
      ball.vx = ball.vx - 2 * dot * nx;
      ball.vy = ball.vy - 2 * dot * ny;
    }

    function circleSegmentCollision(ball, edge) {
      const { a, b } = edge;
      const vx = b.x - a.x, vy = b.y - a.y;
      const wx = ball.x - a.x, wy = ball.y - a.y;
      const proj = (wx * vx + wy * vy) / (vx * vx + vy * vy);
      const t = Math.max(0, Math.min(1, proj));
      const closestX = a.x + t * vx, closestY = a.y + t * vy;
      const dx = ball.x - closestX, dy = ball.y - closestY;
      return (dx * dx + dy * dy) <= ball.radius * ball.radius;
    }

    function reflectBallIfEdgeCollision(ball, polygon) {
      const edges = getEdges(polygon);
      for (const edge of edges) {
        if (circleSegmentCollision(ball, edge)) {
          reflectBall(ball, edge);
          // move ball slightly out along new velocity direction
          const norm = Math.hypot(ball.vx, ball.vy);
          if (norm > 0) {
            ball.x += (ball.vx / norm) * ball.radius * 0.1;
            ball.y += (ball.vy / norm) * ball.radius * 0.1;
          }
        }
      }
    }

    function pointInPolygon(pt, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
          (pt.x < ((xj - xi) * (pt.y - yi)) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
             q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }

    function orient(a, b, c) {
      return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    }

    function segmentsIntersect(p1, p2, p3, p4) {
      const o1 = orient(p1, p2, p3);
      const o2 = orient(p1, p2, p4);
      const o3 = orient(p3, p4, p1);
      const o4 = orient(p3, p4, p2);

      if (o1 === 0 && onSegment(p1, p3, p2)) return true;
      if (o2 === 0 && onSegment(p1, p4, p2)) return true;
      if (o3 === 0 && onSegment(p3, p1, p4)) return true;
      if (o4 === 0 && onSegment(p3, p2, p4)) return true;

      if ((o1 > 0 && o2 < 0 || o1 < 0 && o2 > 0) &&
          (o3 > 0 && o4 < 0 || o3 < 0 && o4 > 0)) {
        return true;
      }
      return false;
    }

    function lineIntersectsPolygon(a, b, poly) {
      if (pointInPolygon(a, poly) || pointInPolygon(b, poly)) return true;
      for (let i = 0; i < poly.length; i++) {
        const c = poly[i];
        const d = poly[(i + 1) % poly.length];
        if (segmentsIntersect(a, b, c, d)) return true;
      }
      return false;
    }

    function getCanvasCoords(evt) {
      const rect = GAME.canvas.getBoundingClientRect();
      const scaleX = GAME.canvas.width / rect.width;
      const scaleY = GAME.canvas.height / rect.height;
      let clientX, clientY;
      if (evt.touches && evt.touches.length > 0) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
      }
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;
      return { x, y };
    }

    // ==== POLYGON CLIPPING ====
    function cutPolygon(playfield, sliceLine) {
      const thickness = 2; // px
      const dx = sliceLine[1].x - sliceLine[0].x;
      const dy = sliceLine[1].y - sliceLine[0].y;
      const len = Math.hypot(dx, dy);
      if (len < 1) return [playfield];

      const nx = -dy / len, ny = dx / len;
      const p1 = { x: sliceLine[0].x + nx * thickness, y: sliceLine[0].y + ny * thickness };
      const p2 = { x: sliceLine[1].x + nx * thickness, y: sliceLine[1].y + ny * thickness };
      const p3 = { x: sliceLine[1].x - nx * thickness, y: sliceLine[1].y - ny * thickness };
      const p4 = { x: sliceLine[0].x - nx * thickness, y: sliceLine[0].y - ny * thickness };
      const cutPoly = [p1, p2, p3, p4];

      const subj = toClipper([playfield]);
      const clip = toClipper([cutPoly]);
      const cpr = new ClipperLib.Clipper();
      cpr.AddPaths(subj, ClipperLib.PolyType.ptSubject, true);
      cpr.AddPaths(clip, ClipperLib.PolyType.ptClip, true);
      const solution = new ClipperLib.Paths();
      cpr.Execute(
        ClipperLib.ClipType.ctDifference,
        solution,
        ClipperLib.PolyFillType.pftNonZero,
        ClipperLib.PolyFillType.pftNonZero
      );
      if (solution.length === 0) return [];
      return fromClipper(solution);
    }

    // ==== LEVEL MANAGEMENT ====
    function setupLevel(i) {
      GAME.level = i;
      GAME.lives = 3;
      GAME.playfield = [
        { x: 0, y: 0 },
        { x: GAME.width, y: 0 },
        { x: GAME.width, y: GAME.height },
        { x: 0, y: GAME.height }
      ];
      GAME.initialArea = polygonArea(GAME.playfield);
      GAME.remainingArea = 1;
      GAME.targetPercent = Math.min(90, 70 + i * 2);

      // Initialize balls
      GAME.balls = [];
      const ballCount = 1 + Math.floor(i / 2);
      for (let b = 0; b < ballCount; b++) {
        const radius = 10;
        const x = radius + Math.random() * (GAME.width - 2 * radius);
        const y = radius + Math.random() * (GAME.height - 2 * radius);
        const speed = 100 + i * 10;
        const angle = Math.random() * Math.PI * 2;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        GAME.balls.push({ x, y, vx, vy, radius });
      }
    }

    function nextLevel() {
      GAME.isAnimating = false;
      setupLevel(GAME.level + 1);
      // Reset lastTimestamp for smooth animation
      GAME.lastTimestamp = performance.now();
    }

    function gameOver() {
      alert("Game Over! Restarting from Level 1.");
      setupLevel(0);
      GAME.lastTimestamp = performance.now();
    }

    function loseLife() {
      GAME.lives--;
      if (GAME.lives <= 0) {
        GAME.isCutting = false;
        GAME.slice = null;
        gameOver();
      }
    }

    function onLevelComplete() {
      GAME.isAnimating = true;
      const pf = GAME.playfield;
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const p of pf) {
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
      }
      const boxW = maxX - minX, boxH = maxY - minY;
      const scaleX = GAME.width / boxW;
      const scaleY = GAME.height / boxH;
      const finalScale = Math.min(scaleX, scaleY);
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      const tx = GAME.width / 2 - centerX * finalScale;
      const ty = GAME.height / 2 - centerY * finalScale;

      const duration = 0.5; // seconds
      let startTime = null;

      function scaleAnimationStep(timestamp) {
        if (!startTime) startTime = timestamp;
        const t = (timestamp - startTime) / 1000;
        const elapsed = Math.min(duration, t);
        const frac = elapsed / duration;

        const curScale = 1 + (finalScale - 1) * frac;
        const curTx = tx * frac;
        const curTy = ty * frac;

        GAME.ctx.clearRect(0, 0, GAME.width, GAME.height);
        GAME.ctx.save();
        GAME.ctx.setTransform(curScale, 0, 0, curScale, curTx, curTy);

        // Draw scaled playfield
        GAME.ctx.fillStyle = "#222";
        GAME.ctx.strokeStyle = "#888";
        GAME.ctx.lineWidth = 2 / curScale;
        GAME.ctx.beginPath();
        GAME.ctx.moveTo(pf[0].x, pf[0].y);
        for (let i = 1; i < pf.length; i++) {
          GAME.ctx.lineTo(pf[i].x, pf[i].y);
        }
        GAME.ctx.closePath();
        GAME.ctx.fill();
        GAME.ctx.stroke();

        // Draw balls inside (scaled)
        for (const ball of GAME.balls) {
          GAME.ctx.beginPath();
          GAME.ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
          GAME.ctx.fillStyle = "#f06";
          GAME.ctx.fill();
          GAME.ctx.strokeStyle = "#fff";
          GAME.ctx.lineWidth = 1 / curScale;
          GAME.ctx.stroke();
        }

        GAME.ctx.restore();

        if (elapsed < duration) {
          requestAnimationFrame(scaleAnimationStep);
        } else {
          nextLevel();
        }
      }

      requestAnimationFrame(scaleAnimationStep);
    }

    // ==== GAME LOOP ====
    function update(delta) {
      if (GAME.isAnimating) return;

      // Move and bounce balls
      for (const ball of GAME.balls) {
        ball.x += ball.vx * delta;
        ball.y += ball.vy * delta;
        reflectBallIfEdgeCollision(ball, GAME.playfield);
      }

      // If slicing, check for ball-slice collisions
      if (GAME.isCutting && GAME.slice) {
        for (const ball of GAME.balls) {
          if (circleSegmentCollision(ball, { a: GAME.slice.start, b: GAME.slice.end })) {
            loseLife();
            GAME.isCutting = false;
            GAME.slice = null;
            break;
          }
        }
      }
    }

    function render() {
      if (GAME.isAnimating) return;
      const ctx = GAME.ctx;
      ctx.clearRect(0, 0, GAME.width, GAME.height);

      // Draw playfield
      ctx.fillStyle = "#222";
      ctx.strokeStyle = "#888";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const pf = GAME.playfield;
      ctx.moveTo(pf[0].x, pf[0].y);
      for (let i = 1; i < pf.length; i++) {
        ctx.lineTo(pf[i].x, pf[i].y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Draw balls
      for (const ball of GAME.balls) {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#f06";
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Draw slice line if active
      if (GAME.isCutting && GAME.slice) {
        ctx.strokeStyle = "#0f0";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(GAME.slice.start.x, GAME.slice.start.y);
        ctx.lineTo(GAME.slice.end.x, GAME.slice.end.y);
        ctx.stroke();
      }

      drawUI();
    }

    function loop(timestamp) {
      if (!GAME.lastTimestamp) GAME.lastTimestamp = timestamp;
      const delta = (timestamp - GAME.lastTimestamp) / 1000;
      GAME.lastTimestamp = timestamp;

      update(delta);
      render();
      requestAnimationFrame(loop);
    }

    // ==== INPUT HANDLERS ====
    function onPointerDown(evt) {
      if (GAME.isAnimating) return;
      const { x, y } = getCanvasCoords(evt);
      GAME.isCutting = true;
      GAME.slice = { start: { x, y }, end: { x, y } };
      evt.preventDefault();
    }

    function onPointerMove(evt) {
      if (!GAME.isCutting || GAME.isAnimating) return;
      const { x, y } = getCanvasCoords(evt);
      GAME.slice.end.x = x;
      GAME.slice.end.y = y;
      evt.preventDefault();
    }

    function onPointerUp(evt) {
      if (!GAME.isCutting || GAME.isAnimating) return;
      const { x, y } = getCanvasCoords(evt);
      GAME.slice.end.x = x;
      GAME.slice.end.y = y;
      GAME.isCutting = false;

      attemptSlice(GAME.slice.start, GAME.slice.end);
      GAME.slice = null;
      evt.preventDefault();
    }

    function attemptSlice(start, end) {
      if (!lineIntersectsPolygon(start, end, GAME.playfield)) return;
      const resultPolys = cutPolygon(GAME.playfield, [start, end]);
      if (resultPolys.length === 0) return;
      const newPlay = keepLargest(resultPolys);
      const newArea = polygonArea(newPlay);
      GAME.remainingArea = newArea / GAME.initialArea;
      GAME.playfield = newPlay;

      const cutPct = (1 - GAME.remainingArea) * 100;
      if (cutPct >= GAME.targetPercent) {
        onLevelComplete();
      }
    }

    // ==== UI DRAW ====
    function drawUI() {
      const ctx = GAME.ctx;
      ctx.font = "20px Arial";
      ctx.fillStyle = "#fff";
      ctx.fillText("Lives: " + GAME.lives, 20, 30);
      const pct = Math.round((1 - GAME.remainingArea) * 100);
      ctx.fillText(pct + "% cut", GAME.width - 100, 30);
    }

    // ==== INITIALIZATION ====
    function init() {
      GAME.canvas = document.getElementById("gameCanvas");
      GAME.ctx = GAME.canvas.getContext("2d");

      GAME.canvas.width = GAME.width;
      GAME.canvas.height = GAME.height;

      setupLevel(0);

      GAME.canvas.addEventListener("mousedown", onPointerDown);
      GAME.canvas.addEventListener("mousemove", onPointerMove);
      GAME.canvas.addEventListener("mouseup", onPointerUp);
      GAME.canvas.addEventListener("mouseleave", onPointerUp);

      GAME.canvas.addEventListener("touchstart", onPointerDown);
      GAME.canvas.addEventListener("touchmove", onPointerMove);
      GAME.canvas.addEventListener("touchend", onPointerUp);

      requestAnimationFrame(loop);
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>
```
