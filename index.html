<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Metro Transit Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            background: #2a2a2a;
            cursor: crosshair;
        }

        .hud {
            position: absolute;
            z-index: 10;
            pointer-events: none;
        }

        .top-bar {
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: auto;
        }

        .bottom-bar {
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 14px;
        }

        .stat-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat {
            font-weight: bold;
        }

        .resource-panel {
            position: absolute;
            top: 60px;
            right: -300px;
            width: 280px;
            height: calc(100vh - 60px);
            background: rgba(0, 0, 0, 0.9);
            transition: right 0.3s ease;
            padding: 20px;
            pointer-events: auto;
        }

        .resource-panel.open {
            right: 0;
        }

        .resource-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: #4a4a4a;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 14px;
            transition: background 0.2s;
        }

        .resource-button:hover:not(:disabled) {
            background: #5a5a5a;
        }

        .resource-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-over-modal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .modal-content {
            background: #333;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .modal-content p {
            margin: 10px 0;
        }

        .modal-button {
            padding: 10px 20px;
            margin: 10px;
            background: #4a90e2;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }

        .modal-button:hover {
            background: #357abd;
        }

        .pause-modal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .tutorial-modal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .tutorial-content {
            background: #333;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            text-align: center;
        }

        .tutorial-step {
            display: none;
            margin: 20px 0;
        }

        .tutorial-step.active {
            display: block;
        }

        .clickable {
            pointer-events: auto;
            cursor: pointer;
        }

        .notification {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(74, 144, 226, 0.9);
            padding: 15px;
            border-radius: 5px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            pointer-events: none;
        }

        .notification.show {
            transform: translateX(0);
        }

        @media (max-width: 768px) {
            .top-bar {
                padding: 0 10px;
                font-size: 14px;
            }
            
            .stat-group {
                gap: 10px;
            }
            
            .resource-panel {
                width: 100%;
                right: -100%;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD Elements -->
    <div class="hud top-bar">
        <div class="stat-group">
            <span class="stat">Week: <span id="weekDisplay">1</span></span>
            <span class="stat">Month: <span id="monthDisplay">1</span></span>
        </div>
        <div class="stat-group">
            <span class="stat">Delivered: <span id="scoreDisplay">0</span></span>
            <span class="stat clickable" id="tokensDisplay" style="color: #4a90e2;">Tokens: 0</span>
            <button class="modal-button" id="pauseButton">‚è∏</button>
        </div>
    </div>

    <div class="hud bottom-bar">
        <span id="tooltipDisplay">
            Draw lines between stations to connect them. Trains will carry passengers to matching colored stations.
        </span>
    </div>

    <!-- Resource Panel -->
    <div class="resource-panel" id="resourcePanel">
        <h3>Spend Resources</h3>
        <button class="resource-button" id="addTrainBtn" data-cost="1">
            üöÇ Add Train (1 Token)
            <br><small>Add a new train to an existing line</small>
        </button>
        <button class="resource-button" id="addCarriageBtn" data-cost="1">
            üöÉ Add Carriage (1 Token)
            <br><small>Increase train capacity by 4</small>
        </button>
        <button class="resource-button" id="addLineBtn" data-cost="1">
            üìè New Line (1 Token)
            <br><small>Unlock ability to draw another line</small>
        </button>
        <button class="resource-button" id="addTunnelBtn" data-cost="1">
            üöá Tunnel (1 Token)
            <br><small>Cross barriers with next line segment</small>
        </button>
        <button class="resource-button" id="closeResourcePanel">Close</button>
    </div>

    <!-- Game Over Modal -->
    <div class="game-over-modal" id="gameOverModal">
        <div class="modal-content">
            <h2>Game Over!</h2>
            <p id="gameOverReason">Station Overloaded</p>
            <p>Time Survived: <span id="finalWeek">0</span> weeks</p>
            <p>Passengers Delivered: <span id="finalScore">0</span></p>
            <p>Average Wait Time: <span id="avgWaitTime">0.0s</span></p>
            <button class="modal-button" id="restartButton">Restart Game</button>
        </div>
    </div>

    <!-- Pause Modal -->
    <div class="pause-modal" id="pauseModal">
        <div class="modal-content">
            <h2>Game Paused</h2>
            <button class="modal-button" id="resumeButton">Resume</button>
            <button class="modal-button" id="restartFromPauseButton">Restart</button>
            <button class="modal-button" id="tutorialButton">Tutorial</button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="tutorial-modal" id="tutorialModal" style="display: none;">
        <div class="tutorial-content">
            <div class="tutorial-step active">
                <h3>Welcome to Mini Metro!</h3>
                <p>Build an efficient transit network by connecting stations with colored lines.</p>
                <button class="modal-button" onclick="nextTutorialStep()">Next</button>
            </div>
            <div class="tutorial-step">
                <h3>Drawing Lines</h3>
                <p>Click and drag from one station to another to create your first line. Trains will automatically run on your lines.</p>
                <button class="modal-button" onclick="nextTutorialStep()">Next</button>
            </div>
            <div class="tutorial-step">
                <h3>Passengers & Colors</h3>
                <p>Colored passengers appear at stations and want to travel to stations of matching color. Keep queues short!</p>
                <button class="modal-button" onclick="nextTutorialStep()">Next</button>
            </div>
            <div class="tutorial-step">
                <h3>Resources & Upgrades</h3>
                <p>Every week you'll receive tokens. Spend them to add trains, carriages, new lines, and tunnels. Click the 'Tokens' counter to spend.</p>
                <button class="modal-button" onclick="nextTutorialStep()">Next</button>
            </div>
            <div class="tutorial-step">
                <h3>Win Condition</h3>
                <p>If any station's queue exceeds 20 passengers, you lose! Build smart and keep traffic flowing.</p>
                <button class="modal-button" onclick="startGame()">Start Playing!</button>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // -------------------------
        // Game Constants
        // -------------------------
        const STATION_COLORS = [
            '#ff6b6b',' #4ecdc4',' #45b7d1',' #f9ca24',' #f0932b',' #eb4d4b'
        ];
        const LINE_COLORS = ['#666','#777','#888','#999','#aaa','#bbb'];
        const STATION_RADIUS = 15;
        const TRAIN_SIZE = 8;
        const MAX_QUEUE_LENGTH = 20;
        const REAL_SECONDS_PER_WEEK = 20; // 20s = 1 ‚Äúweek‚Äù (sped up for testing)
        const DEFAULT_TRAIN_SPEED = 80;  // px/sec
        const DEFAULT_TRAIN_CAPACITY = 4;

        // -------------------------
        // Game State
        // -------------------------
        let gameState = {
            stations: new Map(),
            lines: new Map(),
            trains: new Map(),
            passengers: new Map(),
            nextStationID: 1,
            nextLineID: 1,
            nextTrainID: 1,
            nextPassengerID: 1,
            score: 0,
            totalWaitTime: 0,
            deliveredCount: 0,
            week: 1,
            month: 1,
            isGameOver: false,
            isPaused: true,    // start paused until tutorial closes
            tokens: 1,
            maxLines: 2,
            usedLines: 0,
            tunnelsAvailable: 0
        };

        // -------------------------
        // Timing Variables
        // -------------------------
        let lastTime = 0;
        let stationSpawnTimer = 0;
        let passengerSpawnTimer = 0;
        let weekTimer = 0;
        let stationSpawnInterval = 8;    // spawn a station every 8s initially
        let passengerSpawnInterval = 1.2; // spawn a passenger every 1.2s

        // -------------------------
        // UI State
        // -------------------------
        let selectedStation = null;
        let isDragging = false;
        let dragEndX = 0;
        let dragEndY = 0;
        let mouseX = 0;
        let mouseY = 0;
        let showingResourcePanel = false;
        let pendingResourceAction = null; // 'addTrain' or 'addCarriage'
        let tutorialStep = 0;

        // -------------------------
        // Canvas Setup
        // -------------------------
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
        }

        // -------------------------
        // Station Class
        // -------------------------
        class Station {
            constructor(x, y, color) {
                this.id = gameState.nextStationID++;
                this.x = x;
                this.y = y;
                this.color = color;
                this.queue = [];    // array of passenger IDs
                this.isOverloaded = false;
            }

            addPassenger(passenger) {
                this.queue.push(passenger.id);
                if (this.queue.length >= MAX_QUEUE_LENGTH && !gameState.isGameOver) {
                    this.isOverloaded = true;
                    endGame(`Station overloaded! Queue reached ${this.queue.length} passengers.`);
                }
            }

            removePassenger(passengerId) {
                const idx = this.queue.indexOf(passengerId);
                if (idx > -1) {
                    this.queue.splice(idx, 1);
                }
            }

            draw() {
                const pulseTime = performance.now() * 0.005;
                const isWarning = this.queue.length >= 15;
                const radius = STATION_RADIUS + (isWarning ? Math.sin(pulseTime) * 3 : 0);

                // Draw station circle
                ctx.fillStyle = this.color;
                ctx.strokeStyle = isWarning ? '#ff0000' : '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Draw up to 4 passenger‚Äêcolor dots inside
                if (this.queue.length > 0) {
                    const displayCount = Math.min(4, this.queue.length);
                    for (let i = 0; i < displayCount; i++) {
                        const passenger = gameState.passengers.get(this.queue[i]);
                        if (passenger) {
                            const angle = (i / displayCount) * Math.PI * 2;
                            const qx = this.x + Math.cos(angle) * (radius - 6);
                            const qy = this.y + Math.sin(angle) * (radius - 6);
                            ctx.fillStyle = passenger.targetColor;
                            ctx.beginPath();
                            ctx.arc(qx, qy, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    if (this.queue.length > 4) {
                        ctx.fillStyle = 'white';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`+${this.queue.length - 4}`, this.x, this.y + radius + 15);
                    }
                }
            }
        }

        // -------------------------
        // Line Class
        // -------------------------
        class Line {
            constructor() {
                this.id = gameState.nextLineID++;
                this.stations = [];     // array of station IDs, in order
                this.trains = [];       // array of train IDs on this line
                this.color = LINE_COLORS[gameState.usedLines % LINE_COLORS.length];
                gameState.usedLines++;
                this.colorStationsMap = {};  // maps station‚Äêcolor‚Üí[indexes]
            }

            addStation(stationId) {
                if (!this.stations.includes(stationId)) {
                    this.stations.push(stationId);
                    this.updateColorMap();
                }
            }

            updateColorMap() {
                this.colorStationsMap = {};
                this.stations.forEach((sid, idx) => {
                    const st = gameState.stations.get(sid);
                    if (st) {
                        if (!this.colorStationsMap[st.color]) {
                            this.colorStationsMap[st.color] = [];
                        }
                        this.colorStationsMap[st.color].push(idx);
                    }
                });
            }

            canReachColor(fromIdx, targetColor, direction) {
                const arr = this.colorStationsMap[targetColor] || [];
                return arr.some(idx => {
                    if (direction === 'forward') return idx > fromIdx;
                    if (direction === 'backward') return idx < fromIdx;
                    return false;
                });
            }

            draw() {
                if (this.stations.length < 2) return;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                for (let i = 0; i < this.stations.length - 1; i++) {
                    const s1 = gameState.stations.get(this.stations[i]);
                    const s2 = gameState.stations.get(this.stations[i + 1]);
                    if (s1 && s2) {
                        if (i === 0) ctx.moveTo(s1.x, s1.y);
                        ctx.lineTo(s2.x, s2.y);
                    }
                }
                ctx.stroke();
            }
        }

        // -------------------------
        // Train Class
        // -------------------------
        class Train {
            constructor(lineId) {
                this.id = gameState.nextTrainID++;
                this.lineId = lineId;
                this.currentStationIndex = 0;
                this.direction = 'forward';
                this.speed = DEFAULT_TRAIN_SPEED;
                this.capacity = DEFAULT_TRAIN_CAPACITY;
                this.passengers = [];  // array of passenger IDs
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;

                const ln = gameState.lines.get(lineId);
                if (ln && ln.stations.length > 0) {
                    const firstSt = gameState.stations.get(ln.stations[0]);
                    if (firstSt) {
                        this.x = firstSt.x;
                        this.y = firstSt.y;
                        this.updateTarget();
                    }
                }
            }

            updateTarget() {
                const ln = gameState.lines.get(this.lineId);
                if (!ln || ln.stations.length < 2) return;

                let nextIdx = this.direction === 'forward'
                    ? this.currentStationIndex + 1
                    : this.currentStationIndex - 1;

                if (nextIdx >= ln.stations.length) {
                    this.direction = 'backward';
                    this.currentStationIndex = ln.stations.length - 1;
                    nextIdx = this.currentStationIndex - 1;
                } else if (nextIdx < 0) {
                    this.direction = 'forward';
                    this.currentStationIndex = 0;
                    nextIdx = this.currentStationIndex + 1;
                }

                const tgtSt = gameState.stations.get(ln.stations[nextIdx]);
                if (tgtSt) {
                    this.targetX = tgtSt.x;
                    this.targetY = tgtSt.y;
                }
            }

            update(deltaTime) {
                if (gameState.isPaused || gameState.isGameOver) return;
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 2) {
                    this.arriveAtStation();
                } else {
                    const moveDist = this.speed * deltaTime;
                    this.x += (dx/dist) * moveDist;
                    this.y += (dy/dist) * moveDist;
                }
            }

            arriveAtStation() {
                const ln = gameState.lines.get(this.lineId);
                if (!ln) return;
                let nextIdx = this.direction === 'forward'
                    ? this.currentStationIndex + 1
                    : this.currentStationIndex - 1;
                this.currentStationIndex = nextIdx;

                const curSt = gameState.stations.get(ln.stations[nextIdx]);
                if (curSt) {
                    this.x = curSt.x;
                    this.y = curSt.y;

                    // Deboard
                    this.passengers = this.passengers.filter(pid => {
                        const p = gameState.passengers.get(pid);
                        if (p && p.targetColor === curSt.color) {
                            gameState.score++;
                            gameState.deliveredCount++;
                            gameState.totalWaitTime += p.waitDuration;
                            gameState.passengers.delete(pid);
                            updateUI();
                            return false;
                        }
                        return true;
                    });

                    // Board
                    const spaceLeft = this.capacity - this.passengers.length;
                    let boarded = 0;
                    for (let i = 0; i < curSt.queue.length && boarded < spaceLeft; i++) {
                        const pid = curSt.queue[i];
                        const p = gameState.passengers.get(pid);
                        if (p && this.canReachColor(p.targetColor)) {
                            this.passengers.push(pid);
                            curSt.removePassenger(pid);
                            boarded++;
                            i--; // because array shortened
                        }
                    }
                }
                this.updateTarget();
            }

            canReachColor(targetColor) {
                const ln = gameState.lines.get(this.lineId);
                if (!ln) return false;
                return ln.canReachColor(
                    this.currentStationIndex, 
                    targetColor, 
                    this.direction
                ) || ln.canReachColor(
                    this.currentStationIndex,
                    targetColor,
                    this.direction === 'forward' ? 'backward' : 'forward'
                );
            }

            draw() {
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, TRAIN_SIZE, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Show capacity text above train
                ctx.fillStyle = 'black';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `${this.passengers.length}/${this.capacity}`, 
                    this.x, 
                    this.y - TRAIN_SIZE - 5
                );
            }
        }

        // -------------------------
        // Passenger Class
        // -------------------------
        class Passenger {
            constructor(originStationId, targetColor) {
                this.id = gameState.nextPassengerID++;
                this.originStationId = originStationId;
                this.targetColor = targetColor;
                this.spawnTime = performance.now();
                this.waitDuration = 0;
            }

            update(deltaTime) {
                this.waitDuration += deltaTime;
            }
        }

        // -------------------------
        // Initialize / Reset Game
        // -------------------------
        function initGame() {
            gameState = {
                stations: new Map(),
                lines: new Map(),
                trains: new Map(),
                passengers: new Map(),
                nextStationID: 1,
                nextLineID: 1,
                nextTrainID: 1,
                nextPassengerID: 1,
                score: 0,
                totalWaitTime: 0,
                deliveredCount: 0,
                week: 1,
                month: 1,
                isGameOver: false,
                isPaused: true, // remain paused until tutorial closes
                tokens: 1,
                maxLines: 2,
                usedLines: 0,
                tunnelsAvailable: 0
            };

            stationSpawnTimer = 0;
            passengerSpawnTimer = 0;
            weekTimer = 0;
            stationSpawnInterval = 8;
            passengerSpawnInterval = 1.2;

            // Spawn 2 stations right away, and a third after 2s
            spawnStation();
            spawnStation();
            setTimeout(spawnStation, 2000);

            updateUI();
        }

        // -------------------------
        // Spawn a New Station
        // -------------------------
        function spawnStation() {
            if (gameState.isGameOver) return;
            let tries = 0;
            let x, y;
            const minDist = 80;
            do {
                x = Math.random() * (window.innerWidth - 100) + 50;
                y = Math.random() * (window.innerHeight - 160) + 80;
                tries++;
            } while (
                tries < 20 &&
                Array.from(gameState.stations.values()).some(st => {
                    const dx = st.x - x;
                    const dy = st.y - y;
                    return Math.sqrt(dx*dx + dy*dy) < minDist;
                })
            );
            const color = STATION_COLORS[
                Math.floor(Math.random() * STATION_COLORS.length)
            ];
            const station = new Station(x, y, color);
            gameState.stations.set(station.id, station);
        }

        // -------------------------
        // Spawn a New Passenger
        // -------------------------
        function spawnPassenger() {
            if (gameState.isGameOver || gameState.stations.size === 0) return;
            const allStations = Array.from(gameState.stations.values());
            const randomSt = allStations[
                Math.floor(Math.random() * allStations.length)
            ];
            const availableColors = STATION_COLORS.filter(
                c => c !== randomSt.color
            );
            if (availableColors.length === 0) return;
            const targetColor = availableColors[
                Math.floor(Math.random() * availableColors.length)
            ];
            const p = new Passenger(randomSt.id, targetColor);
            gameState.passengers.set(p.id, p);
            randomSt.addPassenger(p);
        }

        // -------------------------
        // Main Game Logic Update
        // -------------------------
        function updateGameLogic(deltaTime) {
            if (gameState.isPaused || gameState.isGameOver) return;

            stationSpawnTimer += deltaTime;
            passengerSpawnTimer += deltaTime;
            weekTimer += deltaTime;

            if (stationSpawnTimer >= stationSpawnInterval) {
                spawnStation();
                stationSpawnTimer = 0;
            }

            if (passengerSpawnTimer >= passengerSpawnInterval) {
                spawnPassenger();
                passengerSpawnTimer = 0;
            }

            if (weekTimer >= REAL_SECONDS_PER_WEEK) {
                gameState.week++;
                if (gameState.week > 4) {
                    gameState.week = 1;
                    gameState.month++;
                    stationSpawnInterval = Math.max(3, stationSpawnInterval - 0.5);
                    passengerSpawnInterval = Math.max(0.5, passengerSpawnInterval - 0.1);
                }
                gameState.tokens++;
                showNotification(`Week ${gameState.week}: +1 Token`);
                weekTimer = 0;
                updateUI();
            }

            gameState.trains.forEach(tr => tr.update(deltaTime));
            gameState.passengers.forEach(p => p.update(deltaTime));
        }

        // -------------------------
        // Render Everything
        // -------------------------
        function render() {
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

            // Draw subtle grid
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            const grid = 50;
            for (let x = 0; x < window.innerWidth; x += grid) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, window.innerHeight);
                ctx.stroke();
            }
            for (let y = 0; y < window.innerHeight; y += grid) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(window.innerWidth, y);
                ctx.stroke();
            }

            // Draw lines
            gameState.lines.forEach(ln => ln.draw());

            // Draw preview if dragging
            if (isDragging && selectedStation) {
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 4;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(selectedStation.x, selectedStation.y);
                ctx.lineTo(dragEndX, dragEndY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw stations
            gameState.stations.forEach(st => st.draw());

            // Draw trains
            gameState.trains.forEach(tr => tr.draw());
        }

        // -------------------------
        // Main Loop
        // -------------------------
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
            lastTime = timestamp;
            updateGameLogic(dt);
            render();
            requestAnimationFrame(gameLoop);
        }

        // -------------------------
        // UI Updates
        // -------------------------
        function updateUI() {
            document.getElementById('weekDisplay').textContent = gameState.week;
            document.getElementById('monthDisplay').textContent = gameState.month;
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('tokensDisplay').textContent = `Tokens: ${gameState.tokens}`;

            const hasTokens = gameState.tokens > 0;
            document.getElementById('addTrainBtn').disabled = !hasTokens || gameState.lines.size === 0;
            document.getElementById('addCarriageBtn').disabled = !hasTokens || gameState.trains.size === 0;
            document.getElementById('addLineBtn').disabled = !hasTokens || gameState.usedLines >= 6;
            document.getElementById('addTunnelBtn').disabled = !hasTokens;
        }

        // -------------------------
        // End Game
        // -------------------------
        function endGame(reason) {
            gameState.isGameOver = true;
            document.getElementById('gameOverReason').textContent = reason;
            const weeksSurvived = (gameState.month - 1) * 4 + gameState.week;
            document.getElementById('finalWeek').textContent = weeksSurvived;
            document.getElementById('finalScore').textContent = gameState.score;
            const avg = gameState.deliveredCount > 0
                ? (gameState.totalWaitTime / gameState.deliveredCount).toFixed(1)
                : '0.0';
            document.getElementById('avgWaitTime').textContent = `${avg}s`;
            document.getElementById('gameOverModal').style.display = 'flex';
        }

        // -------------------------
        // Show Notification
        // -------------------------
        function showNotification(txt) {
            const n = document.getElementById('notification');
            n.textContent = txt;
            n.classList.add('show');
            setTimeout(() => n.classList.remove('show'), 2000);
        }

        // -------------------------
        // Handle Resource Actions
        // -------------------------
        function toggleResourcePanel() {
            showingResourcePanel = !showingResourcePanel;
            document.getElementById('resourcePanel').classList.toggle('open', showingResourcePanel);
        }
        function closeResourcePanel() {
            showingResourcePanel = false;
            document.getElementById('resourcePanel').classList.remove('open');
            pendingResourceAction = null;
            document.getElementById('tooltipDisplay').textContent =
                'Draw lines between stations to connect them. Trains carry passengers to matching colors.';
        }

        function handleResourceAction(action) {
            if (gameState.tokens <= 0) return;
            gameState.tokens--;
            updateUI();

            if (action === 'addTrain') {
                pendingResourceAction = 'addTrain';
                document.getElementById('tooltipDisplay').textContent = 
                    'Click a station on a line to add a new train to that line.';
            }
            if (action === 'addCarriage') {
                pendingResourceAction = 'addCarriage';
                document.getElementById('tooltipDisplay').textContent =
                    'Click a train to increase its capacity by 4.';
            }
            if (action === 'addLine') {
                gameState.maxLines++;
                showNotification('New line unlocked!');
                setTimeout(closeResourcePanel, 200);
            }
            if (action === 'addTunnel') {
                gameState.tunnelsAvailable++;
                showNotification('Tunnel token acquired! (No barriers implemented)');
                setTimeout(closeResourcePanel, 200);
            }
        }

        function tryPlaceTrainAtStation(stationId) {
            for (let [lineId, ln] of gameState.lines) {
                if (ln.stations.includes(stationId)) {
                    const tr = new Train(lineId);
                    gameState.trains.set(tr.id, tr);
                    ln.trains.push(tr.id);
                    showNotification('Train added to that line.');
                    pendingResourceAction = null;
                    updateUI();
                    closeResourcePanel();
                    return true;
                }
            }
            return false;
        }

        function tryAddCarriageToTrainAt(x, y) {
            for (let [trainId, tr] of gameState.trains) {
                const dx = tr.x - x, dy = tr.y - y;
                if (Math.sqrt(dx*dx + dy*dy) <= TRAIN_SIZE + 2) {
                    tr.capacity += 4;
                    showNotification('Train capacity increased by 4.');
                    pendingResourceAction = null;
                    updateUI();
                    closeResourcePanel();
                    return true;
                }
            }
            return false;
        }

        // -------------------------
        // Handle Connecting Two Stations
        // -------------------------
        function handleNewConnection(stA, stB) {
            if (stA.id === stB.id) return;

            // 1) If either station belongs to an existing line, append the other station there
            for (let [lnId, ln] of gameState.lines) {
                const idxA = ln.stations.indexOf(stA.id);
                const idxB = ln.stations.indexOf(stB.id);
                if (idxA !== -1 && idxB === -1) {
                    ln.stations.splice(idxA + 1, 0, stB.id);
                    ln.updateColorMap();
                    return;
                }
                if (idxB !== -1 && idxA === -1) {
                    ln.stations.splice(idxB + 1, 0, stA.id);
                    ln.updateColorMap();
                    return;
                }
            }

            // 2) Otherwise, if we still can create a new line, do so
            if (gameState.usedLines < gameState.maxLines) {
                const newLn = new Line();
                newLn.addStation(stA.id);
                newLn.addStation(stB.id);
                gameState.lines.set(newLn.id, newLn);

                // Spawn a train on that new line
                const tr = new Train(newLn.id);
                gameState.trains.set(tr.id, tr);
                newLn.trains.push(tr.id);
                return;
            }
        }

        // -------------------------
        // Input & Interaction
        // -------------------------
        canvas.addEventListener('mousedown', e => {
            if (gameState.isPaused || gameState.isGameOver) return;
            mouseX = e.clientX;
            mouseY = e.clientY;

            // If user chose ‚ÄúAdd Train,‚Äù detect station click:
            if (pendingResourceAction === 'addTrain') {
                for (let [sid, st] of gameState.stations) {
                    const dx = st.x - mouseX, dy = st.y - mouseY;
                    if (Math.sqrt(dx*dx + dy*dy) <= STATION_RADIUS) {
                        if (tryPlaceTrainAtStation(sid)) return;
                    }
                }
                return;
            }
            // If user chose ‚ÄúAdd Carriage,‚Äù detect train click:
            if (pendingResourceAction === 'addCarriage') {
                if (tryAddCarriageToTrainAt(mouseX, mouseY)) return;
                return;
            }

            // Otherwise, check if we clicked on a station to begin dragging:
            for (let [_, st] of gameState.stations) {
                const dx = st.x - mouseX, dy = st.y - mouseY;
                if (Math.sqrt(dx*dx + dy*dy) <= STATION_RADIUS) {
                    selectedStation = st;
                    isDragging = true;
                    dragEndX = mouseX;
                    dragEndY = mouseY;
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            dragEndX = mouseX;
            dragEndY = mouseY;

            if (gameState.isPaused || gameState.isGameOver) return;
            // Tooltip logic
            let tooltipShown = false;
            // Station hover:
            for (let [_, st] of gameState.stations) {
                const dx = st.x - mouseX, dy = st.y - mouseY;
                if (Math.sqrt(dx*dx + dy*dy) <= STATION_RADIUS) {
                    const counts = {};
                    st.queue.forEach(pid => {
                        const p = gameState.passengers.get(pid);
                        if (p) counts[p.targetColor] = (counts[p.targetColor]||0) + 1;
                    });
                    const breakdown = Object.entries(counts)
                        .map(([c, num]) => `${num}`)
                        .join(', ');
                    document.getElementById('tooltipDisplay').textContent =
                        `Station ${st.id} ‚Ä¢ Queue: ${st.queue.length} ‚Ä¢ Destinations: ${breakdown}`;
                    tooltipShown = true;
                    break;
                }
            }
            if (!tooltipShown) {
                // Train hover:
                for (let [_, tr] of gameState.trains) {
                    const dx = tr.x - mouseX, dy = tr.y - mouseY;
                    if (Math.sqrt(dx*dx + dy*dy) <= TRAIN_SIZE) {
                        const ln = gameState.lines.get(tr.lineId);
                        document.getElementById('tooltipDisplay').textContent =
                            `Train on Line ${ln.id} ‚Ä¢ Speed: ${tr.speed}px/s ‚Ä¢ ` +
                            `Capacity: ${tr.passengers.length}/${tr.capacity} ‚Ä¢ ` +
                            `Next Station: ${ln.stations[tr.currentStationIndex]}`;
                        tooltipShown = true;
                        break;
                    }
                }
            }
            if (!tooltipShown && !pendingResourceAction) {
                document.getElementById('tooltipDisplay').textContent =
                    'Draw lines between stations to connect them. Trains carry passengers to matching colors.';
            }
        });

        canvas.addEventListener('mouseup', e => {
            if (gameState.isPaused || gameState.isGameOver) {
                isDragging = false;
                selectedStation = null;
                return;
            }
            if (!isDragging || !selectedStation) return;

            const endX = e.clientX;
            const endY = e.clientY;
            let targetStation = null;
            for (let [_, st] of gameState.stations) {
                const dx = st.x - endX, dy = st.y - endY;
                if (Math.sqrt(dx*dx + dy*dy) <= STATION_RADIUS) {
                    targetStation = st;
                    break;
                }
            }

            if (targetStation) {
                handleNewConnection(selectedStation, targetStation);
            }
            isDragging = false;
            selectedStation = null;
        });

        // -------------------------
        // Resource Panel & Buttons
        // -------------------------
        document.getElementById('tokensDisplay').addEventListener('click', () => {
            toggleResourcePanel();
        });
        document.getElementById('closeResourcePanel').addEventListener('click', () => {
            closeResourcePanel();
        });

        document.getElementById('addTrainBtn').addEventListener('click', () => {
            handleResourceAction('addTrain');
        });
        document.getElementById('addCarriageBtn').addEventListener('click', () => {
            handleResourceAction('addCarriage');
        });
        document.getElementById('addLineBtn').addEventListener('click', () => {
            handleResourceAction('addLine');
        });
        document.getElementById('addTunnelBtn').addEventListener('click', () => {
            handleResourceAction('addTunnel');
        });

        // -------------------------
        // Pause & Tutorial Buttons
        // -------------------------
        document.getElementById('pauseButton').addEventListener('click', () => {
            gameState.isPaused = true;
            document.getElementById('pauseModal').style.display = 'flex';
        });
        document.getElementById('resumeButton').addEventListener('click', () => {
            gameState.isPaused = false;
            document.getElementById('pauseModal').style.display = 'none';
        });
        document.getElementById('restartFromPauseButton').addEventListener('click', () => {
            document.getElementById('pauseModal').style.display = 'none';
            document.getElementById('gameOverModal').style.display = 'none';
            initGame();
        });
        document.getElementById('tutorialButton').addEventListener('click', () => {
            document.getElementById('tutorialModal').style.display = 'flex';
        });

        // -------------------------
        // Restart Game
        // -------------------------
        document.getElementById('restartButton').addEventListener('click', () => {
            document.getElementById('gameOverModal').style.display = 'none';
            initGame();
        });

        // -------------------------
        // Tutorial Flow
        // -------------------------
        function nextTutorialStep() {
            const steps = document.querySelectorAll('.tutorial-step');
            steps[tutorialStep].classList.remove('active');
            tutorialStep++;
            if (tutorialStep < steps.length) {
                steps[tutorialStep].classList.add('active');
            }
        }
        function startGame() {
            document.getElementById('tutorialModal').style.display = 'none';
            gameState.isPaused = false;
        }

        // -------------------------
        // Startup
        // -------------------------
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            initGame();
            document.getElementById('tutorialModal').style.display = 'flex';
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
