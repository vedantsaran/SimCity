```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Blast - Puzzle Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
        }

        #game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            max-width: 1200px;
            padding: 20px;
        }

        #left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 200px;
        }

        #score-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #score-panel h2 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 24px;
        }

        .score-item {
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
        }

        #score { color: #4CFF4C; }
        #streak { color: #FF4CFF; }
        #best { color: #FFD700; }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            border-radius: 10px;
            color: white;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        #btn-restart {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }

        #btn-mute {
            background: linear-gradient(45deg, #ffa726, #ff7043);
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 15px;
            width: 400px;
            height: 400px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .cell {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            transition: all 0.2s ease;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .cell.occupied {
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .cell.drop-valid {
            background: rgba(76, 255, 76, 0.3) !important;
            border: 2px solid #4CFF4C;
            animation: pulse 0.5s infinite alternate;
        }

        .cell.drop-invalid {
            background: rgba(255, 76, 76, 0.3) !important;
            border: 2px solid #FF4C4C;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        .cell.clearing {
            animation: explode 0.3s ease-out forwards;
        }

        @keyframes explode {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* Colors */
        .color-red { background: linear-gradient(135deg, #FF4C4C, #C62828); }
        .color-green { background: linear-gradient(135deg, #4CFF4C, #2E7D32); }
        .color-blue { background: linear-gradient(135deg, #4C4CFF, #1565C0); }
        .color-yellow { background: linear-gradient(135deg, #FFD700, #F57C00); }
        .color-purple { background: linear-gradient(135deg, #FF4CFF, #7B1FA2); }
        .color-orange { background: linear-gradient(135deg, #FF8C42, #E65100); }

        #preview-area {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 200px;
        }

        #preview-area h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #FFD700;
            font-size: 18px;
        }

        .preview-slot {
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            min-height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            transition: all 0.3s ease;
            border: 2px dashed rgba(255, 255, 255, 0.3);
        }

        .preview-slot:hover {
            transform: scale(1.05);
            border-color: #FFD700;
        }

        .preview-slot.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .preview-piece {
            display: grid;
            gap: 2px;
        }

        .preview-block {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .combo-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            pointer-events: none;
            animation: comboFlash 1s ease-out forwards;
            z-index: 1000;
        }

        @keyframes comboFlash {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5); 
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.2); 
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(1); 
            }
        }

        .board-combo {
            animation: boardFlash 0.5s ease-out;
        }

        @keyframes boardFlash {
            0%, 100% { border-color: rgba(255, 255, 255, 0.2); }
            50% { border-color: #FFD700; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); }
        }

        #game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #FFD700;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8);
            max-width: 400px;
        }

        .modal-content h2 {
            color: #FF4C4C;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 76, 76, 0.5);
        }

        .modal-content .final-score {
            font-size: 24px;
            color: #4CFF4C;
            margin: 20px 0;
        }

        .modal-content button {
            margin: 10px;
            padding: 15px 30px;
            font-size: 18px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #game-container {
                flex-direction: column;
                align-items: center;
                gap: 20px;
                padding: 10px;
            }

            #board {
                width: 320px;
                height: 320px;
            }

            #left-panel {
                width: 100%;
                max-width: 320px;
            }

            #preview-area {
                width: 100%;
                max-width: 320px;
            }

            .preview-slot {
                display: inline-block;
                width: 30%;
                margin: 5px;
            }
        }

        .placed-animation {
            animation: placeAnimation 0.2s ease-out;
        }

        @keyframes placeAnimation {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="left-panel">
            <div id="score-panel">
                <h2>BLOCK BLAST</h2>
                <div class="score-item">Score: <span id="score">0</span></div>
                <div class="score-item">Streak: <span id="streak">0</span></div>
                <div class="score-item">Best: <span id="best">0</span></div>
            </div>
            <div id="controls">
                <button id="btn-restart">ðŸ”„ Restart</button>
                <button id="btn-mute">ðŸ”Š Sound: ON</button>
            </div>
        </div>

        <div id="board"></div>

        <div id="preview-area">
            <h3>Next Pieces</h3>
            <div class="preview-slot" data-index="0"></div>
            <div class="preview-slot" data-index="1"></div>
            <div class="preview-slot" data-index="2"></div>
        </div>
    </div>

    <div id="game-over-modal">
        <div class="modal-content">
            <h2>Game Over!</h2>
            <div class="final-score">Final Score: <span id="final-score">0</span></div>
            <div id="new-best" style="color: #FFD700; font-size: 18px; margin: 10px 0; display: none;">
                ðŸŽ‰ New Best Score! ðŸŽ‰
            </div>
            <button id="btn-play-again">Play Again</button>
        </div>
    </div>

    <script>
        // Game State
        let board = [];
        let upcomingPieces = [];
        let score = 0;
        let streak = 0;
        let bestScore = 0;
        let soundEnabled = true;
        let placedCount = 0;
        let gameRunning = true;

        // Shape definitions
        const SHAPES = {
            single: [[0,0]],
            dominoH: [[0,0],[1,0]],
            dominoV: [[0,0],[0,1]],
            square: [[0,0],[1,0],[0,1],[1,1]],
            lShape: [[0,0],[0,1],[1,1]],
            line3H: [[0,0],[1,0],[2,0]],
            line3V: [[0,0],[0,1],[0,2]],
            tShape: [[0,1],[1,0],[1,1],[1,2]],
            lShapeFlip: [[0,1],[1,0],[1,1]]
        };

        const COLORS = ['red', 'green', 'blue', 'yellow', 'purple', 'orange'];
        const SHAPE_KEYS = Object.keys(SHAPES);

        // Audio context for sound effects
        let audioContext;
        
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) {
                console.log('Audio not supported');
            }
        }

        function playSound(frequency, duration, type = 'sine') {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Initialize game
        function initGame() {
            initAudio();
            loadBestScore();
            createBoard();
            generateNewPieces();
            updateUI();
            setupEventListeners();
        }

        function createBoard() {
            board = Array(8).fill().map(() => Array(8).fill(null));
            renderBoard();
        }

        function renderBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    if (board[row][col]) {
                        cell.classList.add('occupied', `color-${board[row][col].color}`);
                    }
                    
                    boardElement.appendChild(cell);
                }
            }
        }

        function generateRandomPiece() {
            const shapeKey = SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)];
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            
            return {
                shape: SHAPES[shapeKey],
                color: color,
                id: Date.now() + Math.random()
            };
        }

        function generateNewPieces() {
            upcomingPieces = [
                generateRandomPiece(),
                generateRandomPiece(),
                generateRandomPiece()
            ];
            renderPreview();
        }

        function renderPreview() {
            const previewSlots = document.querySelectorAll('.preview-slot');
            
            previewSlots.forEach((slot, index) => {
                slot.innerHTML = '';
                slot.removeAttribute('data-piece-id');
                if (upcomingPieces[index]) {
                    const piece = upcomingPieces[index];
                    const previewPiece = createPreviewPiece(piece);
                    slot.appendChild(previewPiece);
                    slot.dataset.pieceId = piece.id;
                }
            });
        }

        function createPreviewPiece(piece) {
            const bounds = getPieceBounds(piece.shape);
            const container = document.createElement('div');
            container.className = 'preview-piece';
            container.style.gridTemplateColumns = `repeat(${bounds.width}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${bounds.height}, 1fr)`;
            
            for (let row = 0; row < bounds.height; row++) {
                for (let col = 0; col < bounds.width; col++) {
                    const block = document.createElement('div');
                    block.className = 'preview-block';
                    
                    const hasBlock = piece.shape.some(([x, y]) => 
                        x === col + bounds.minX && y === row + bounds.minY
                    );
                    
                    if (hasBlock) {
                        block.classList.add(`color-${piece.color}`);
                    } else {
                        block.style.opacity = '0';
                    }
                    
                    container.appendChild(block);
                }
            }
            
            return container;
        }

        function getPieceBounds(shape) {
            const xs = shape.map(([x, y]) => x);
            const ys = shape.map(([x, y]) => y);
            
            return {
                minX: Math.min(...xs),
                maxX: Math.max(...xs),
                minY: Math.min(...ys),
                maxY: Math.max(...ys),
                width: Math.max(...xs) - Math.min(...xs) + 1,
                height: Math.max(...ys) - Math.min(...ys) + 1
            };
        }

        function isPlacementValid(shape, startRow, startCol) {
            for (const [x, y] of shape) {
                const newRow = startRow + y;
                const newCol = startCol + x;
                
                if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) {
                    return false;
                }
                
                if (board[newRow][newCol] !== null) {
                    return false;
                }
            }
            
            return true;
        }

        function placePiece(piece, startRow, startCol) {
            if (!isPlacementValid(piece.shape, startRow, startCol)) {
                return false;
            }
            
            for (const [x, y] of piece.shape) {
                const newRow = startRow + y;
                const newCol = startCol + x;
                board[newRow][newCol] = { color: piece.color, id: piece.id };
            }
            
            renderBoard();
            addPlacementAnimation(piece.shape, startRow, startCol);
            playSound(440, 0.1);
            
            return true;
        }

        function addPlacementAnimation(shape, startRow, startCol) {
            shape.forEach(([x, y]) => {
                const row = startRow + y;
                const col = startCol + x;
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                    cell.classList.add('placed-animation');
                    setTimeout(() => cell.classList.remove('placed-animation'), 200);
                }
            });
        }

        function findFullLines() {
            const fullRows = [];
            const fullCols = [];
            
            for (let row = 0; row < 8; row++) {
                if (board[row].every(cell => cell !== null)) {
                    fullRows.push(row);
                }
            }
            
            for (let col = 0; col < 8; col++) {
                if (board.every(row => row[col] !== null)) {
                    fullCols.push(col);
                }
            }
            
            return { fullRows, fullCols };
        }

        function clearLines(fullRows, fullCols) {
            const cellsToClear = new Set();
            
            fullRows.forEach(row => {
                for (let col = 0; col < 8; col++) {
                    cellsToClear.add(`${row},${col}`);
                }
            });
            
            fullCols.forEach(col => {
                for (let row = 0; row < 8; row++) {
                    cellsToClear.add(`${row},${col}`);
                }
            });
            
            cellsToClear.forEach(cellKey => {
                const [row, col] = cellKey.split(',').map(Number);
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                    cell.classList.add('clearing');
                }
            });
            
            setTimeout(() => {
                cellsToClear.forEach(cellKey => {
                    const [row, col] = cellKey.split(',').map(Number);
                    board[row][col] = null;
                });
                renderBoard();
            }, 300);
            
            return cellsToClear.size;
        }

        function checkAndClearLines() {
            const { fullRows, fullCols } = findFullLines();
            const totalLines = fullRows.length + fullCols.length;
            
            if (totalLines > 0) {
                const clearedBlocks = clearLines(fullRows, fullCols);
                
                const basePoints = clearedBlocks * 10;
                let multiplier = 1;
                
                if (totalLines >= 4) multiplier = 2.5;
                else if (totalLines >= 3) multiplier = 2.0;
                else if (totalLines >= 2) multiplier = 1.5;
                
                const points = Math.floor(basePoints * multiplier);
                score += points;
                streak++;
                
                if (streak % 5 === 0) {
                    score += 500;
                }
                
                if (totalLines >= 2) {
                    showComboEffect(totalLines, multiplier);
                    document.getElementById('board').classList.add('board-combo');
                    setTimeout(() => {
                        document.getElementById('board').classList.remove('board-combo');
                    }, 500);
                }
                
                if (totalLines >= 3) {
                    playSound(880, 0.3, 'square');
                } else if (totalLines >= 2) {
                    playSound(660, 0.2);
                } else {
                    playSound(550, 0.15);
                }
                
                updateUI();
            } else {
                streak = 0;
                updateUI();
            }
        }

        function showComboEffect(lines, multiplier) {
            const comboElement = document.createElement('div');
            comboElement.className = 'combo-flash';
            comboElement.textContent = `COMBO Ã—${multiplier}!`;
            document.body.appendChild(comboElement);
            
            setTimeout(() => {
                document.body.removeChild(comboElement);
            }, 1000);
        }

        function checkGameOver() {
            for (const piece of upcomingPieces) {
                if (piece && canPieceBePlaced(piece)) {
                    return false;
                }
            }
            return true;
        }

        function canPieceBePlaced(piece) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isPlacementValid(piece.shape, row, col)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function endGame() {
            gameRunning = false;
            
            const isNewBest = score > bestScore;
            if (isNewBest) {
                bestScore = score;
                saveBestScore();
                document.getElementById('new-best').style.display = 'block';
            } else {
                document.getElementById('new-best').style.display = 'none';
            }
            
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over-modal').style.display = 'flex';
            
            playSound(220, 0.5, 'sawtooth');
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('streak').textContent = streak;
            document.getElementById('best').textContent = bestScore;
        }

        function saveBestScore() {
            localStorage.setItem('blockBlastBest', bestScore.toString());
        }

        function loadBestScore() {
            const saved = localStorage.getItem('blockBlastBest');
            bestScore = saved ? parseInt(saved) : 0;
        }

        function restartGame() {
            score = 0;
            streak = 0;
            placedCount = 0;
            gameRunning = true;
            createBoard();
            generateNewPieces();
            updateUI();
            document.getElementById('game-over-modal').style.display = 'none';
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('btn-mute').textContent = soundEnabled ? 'ðŸ”Š Sound: ON' : 'ðŸ”‡ Sound: OFF';
        }

        // Drag and Drop functionality
        let draggedPiece = null;
        let draggedPieceIndex = -1;

        function setupEventListeners() {
            document.getElementById('btn-restart').addEventListener('click', restartGame);
            document.getElementById('btn-mute').addEventListener('click', toggleSound);
            document.getElementById('btn-play-again').addEventListener('click', restartGame);

            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        function handleMouseDown(e) {
            if (!gameRunning) return;
            const previewSlot = e.target.closest('.preview-slot');
            if (previewSlot && previewSlot.dataset.pieceId) {
                startDrag(previewSlot, e.clientX, e.clientY);
            }
        }

        function handleMouseMove(e) {
            if (draggedPiece) {
                updateDragPosition(e.clientX, e.clientY);
                highlightDropZone(e.clientX, e.clientY);
            }
        }

        function handleMouseUp(e) {
            if (draggedPiece) {
                attemptDrop(e.clientX, e.clientY);
            }
        }

        function handleTouchStart(e) {
            if (!gameRunning) return;
            const touch = e.touches[0];
            const previewSlot = touch.target.closest('.preview-slot');
            if (previewSlot && previewSlot.dataset.pieceId) {
                e.preventDefault();
                startDrag(previewSlot, touch.clientX, touch.clientY);
            }
        }

        function handleTouchMove(e) {
            if (draggedPiece) {
                e.preventDefault();
                const touch = e.touches[0];
                updateDragPosition(touch.clientX, touch.clientY);
                highlightDropZone(touch.clientX, touch.clientY);
            }
        }

        function handleTouchEnd(e) {
            if (draggedPiece) {
                e.preventDefault();
                const touch = e.changedTouches[0];
                attemptDrop(touch.clientX, touch.clientY);
            }
        }

        function startDrag(previewSlot, x, y) {
            const pieceId = previewSlot.dataset.pieceId;
            draggedPieceIndex = parseInt(previewSlot.dataset.index);
            draggedPiece = upcomingPieces[draggedPieceIndex];

            previewSlot.classList.add('dragging');

            const floatingPiece = createFloatingPiece(draggedPiece);
            floatingPiece.id = 'floating-piece';
            document.body.appendChild(floatingPiece);

            updateDragPosition(x, y);
        }

        function createFloatingPiece(piece) {
            const container = createPreviewPiece(piece);
            container.style.position = 'fixed';
            container.style.pointerEvents = 'none';
            container.style.zIndex = '1000';
            container.style.transform = 'translate(-50%, -50%)';
            return container;
        }

        function updateDragPosition(x, y) {
            const floatingPiece = document.getElementById('floating-piece');
            if (floatingPiece) {
                floatingPiece.style.left = x + 'px';
                floatingPiece.style.top = y + 'px';
            }
        }

        function highlightDropZone(x, y) {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('drop-valid', 'drop-invalid');
            });

            const targetCell = document.elementFromPoint(x, y);
            if (targetCell && targetCell.classList.contains('cell') && draggedPiece) {
                const row = parseInt(targetCell.dataset.row);
                const col = parseInt(targetCell.dataset.col);

                let valid = true;
                const toHighlight = [];

                for (const [dx, dy] of draggedPiece.shape) {
                    const newRow = row + dy;
                    const newCol = col + dx;

                    if (
                        newRow < 0 || newRow >= 8 ||
                        newCol < 0 || newCol >= 8 ||
                        board[newRow][newCol] !== null
                    ) {
                        valid = false;
                        break;
                    }
                    toHighlight.push([newRow, newCol]);
                }

                if (valid) {
                    toHighlight.forEach(([r, c]) => {
                        const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (cell) cell.classList.add('drop-valid');
                    });
                } else {
                    targetCell.classList.add('drop-invalid');
                }
            }
        }

        function attemptDrop(x, y) {
            const floatingPiece = document.getElementById('floating-piece');
            if (floatingPiece) {
                floatingPiece.remove();
            }

            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('drop-valid', 'drop-invalid');
            });

            const targetCell = document.elementFromPoint(x, y);
            if (targetCell && targetCell.classList.contains('cell') && draggedPiece) {
                const row = parseInt(targetCell.dataset.row);
                const col = parseInt(targetCell.dataset.col);

                if (placePiece(draggedPiece, row, col)) {
                    upcomingPieces[draggedPieceIndex] = null;
                    placedCount++;
                    renderPreview();

                    if (placedCount === 3) {
                        checkAndClearLines();
                        placedCount = 0;
                        generateNewPieces();
                        if (checkGameOver()) {
                            endGame();
                        }
                    }
                }
            }

            const previewSlots = document.querySelectorAll('.preview-slot');
            previewSlots.forEach(slot => slot.classList.remove('dragging'));

            draggedPiece = null;
            draggedPieceIndex = -1;
        }

        // Start everything
        initGame();
    </script>
</body>
</html>
```
